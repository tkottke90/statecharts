---
created: 2025-09-08T22:58:20 (UTC -05:00)
tags: []
source: https://www.w3.org/TR/scxml/
author:
type: Article
---

# State Chart XML (SCXML): State Machine Notation for Control Abstraction

> ## Excerpt
>
> [This section is informative.]

---

## 2 Overview

\[This section is informative.\]

This document outlines State Chart XML (SCXML), which is a general-purpose event-based state machine language that combines concepts from CCXML and Harel State Tables. CCXML [\[CCXML 1.0\]](https://www.w3.org/TR/scxml/#CCXML) is an event-based state machine language designed to support call control features in Voice Applications (specifically including VoiceXML but not limited to it). The CCXML 1.0 specification defines both a state machine and event handing syntax and a standardized set of call control elements. Harel State Tables are a state machine notation that was developed by the mathematician David Harel [\[Harel and Politi\]](https://www.w3.org/TR/scxml/#Harel_Politi) and is included in UML [\[UML 2.3\]](https://www.w3.org/TR/scxml/#UML). They offer a clean and well-thought out semantics for sophisticated constructs such as parallel states. They have been defined as a graphical specification language, however, and hence do not have an XML representation. The goal of this document is to combine Harel semantics with an XML syntax that is a logical extension of CCXML's state and event notation.

[_3 Core Constructs_](https://www.w3.org/TR/scxml/#Basic) presents the core state machine concepts, while [_4 Executable Content_](https://www.w3.org/TR/scxml/#executable) contains an extensible set of actions that the state machine can take in response to events. [_5 Data Model and Data Manipulation_](https://www.w3.org/TR/scxml/#data-module) defines constructs for storing and modifying data, while [_6 External Communications_](https://www.w3.org/TR/scxml/#external-module) provides the capability of communicating with external entities.

## 3 Core Constructs

### 3.1 Introduction

\[This section is informative.\]

#### 3.1.1 Basic State Machine Notation

The most basic state machine concepts are [_3.3 <state>_](https://www.w3.org/TR/scxml/#state), [_3.5 <transition>_](https://www.w3.org/TR/scxml/#transition) and event ([_3.12 SCXML Events_](https://www.w3.org/TR/scxml/#events)). Each state contains a set of transitions that define how it reacts to events. Events can be generated by the state machine itself or by external entities. In a traditional state machine, the machine is always in a single state. This state is called the active state. When an event occurs, the state machine checks the transitions that are defined in the active state. If it finds one that matches the event, it moves from the active state to the state specified by the transition (called the "target" of the transition.) Thus the target state becomes the new active state.

The Harel state notation defines several extensions to these basic notions. First of all, the state machine may take actions (as defined in [_4 Executable Content_](https://www.w3.org/TR/scxml/#executable)) while taking transitions. Specifically, each state may contain [_3.8 <onentry>_](https://www.w3.org/TR/scxml/#onentry) and [_3.9 <onexit>_](https://www.w3.org/TR/scxml/#onexit) actions. Transitions may also contain actions. If a state machine takes transition T from state S1 to state S2, it first performs the onexit actions in S1, then the actions in T, then the onentry actions in S2. Secondly, in addition to the 'event' attribute that specifies the event(s) that can trigger it, transitions also have a 'cond' attribute. If a transition has both 'event' and 'cond' attributes, it will be selected only if an event is raised whose name matches the 'event' attribute (see [_3.12.1 Event Descriptors_](https://www.w3.org/TR/scxml/#EventDescriptors) for details) and the 'cond' condition evaluates to true. If the 'event' attribute is missing, the transition is taken whenever the 'cond' evaluates to true. If more than one transition matches, the first one in document order will be taken. Thus, in the following example, the system will transition to s1 when event e (or e.foo, etc.) occurs if x is equal to 1, but will transition to s2 if event e (or e.foo, etc.) occurs and x is not equal to 1, and will go to s3 if any other event occurs.

```
&lt;state id=s"&gt;
   &lt;transition event="e" cond="x==1" target="s1"/&gt;
   &lt;transition event="e" target="s2"/&gt;
   &lt;transition event="*" target="s3"/&gt;
&lt;/state&gt;
```

#### 3.1.2 Compound States

One of the most powerful concepts in Harel notation is the idea that states may have internal structure. In particular, a <state> element may contain nested <state> elements. Such a state is called a compound state and we speak of it as the parent state, while the nested elements are child states. The child states may themselves have nested children and the nesting may proceed to any depth. Ultimately we will reach a state that does not contain any child states. Such a state is called an atomic state. When a compound state is active, one and only one of its child states is active. Conversely, when an child state is active, its parent state must be active too. Thus at any point we have a set of active states, containing an atomic state and all of its ancestors. (We will see in the next section that multiple atomic states can be active at the same time.)

Compound states also affect how transitions are selected. When looking for transitions, the state machine first looks in the most deeply nested active state(s), i.e., in the atomic state(s) that have no substates. If no transitions match in the atomic state, the state machine will look in its parent state, then in the parent's parent, etc. Thus transitions in ancestor states serve as defaults that will be taken if no transition matches in a descendant state. If no transition matches in any state, the event is discarded.

#### 3.1.3 Parallel States

The <parallel> element represents a state whose children execute in parallel. Like <state>, the <parallel> element contains <onentry>, <onexit>, <transition>, and <state> or <parallel> children. However, the semantics of <parallel> are different. When a <state> is active, exactly one of its children is active. When a <parallel> element is active, _all_ of its children are active. Specifically, when the state machine enters the parent <parallel> state, it also enters each child state. The child states execute in parallel in the sense that any event that is processed is processed in each child state independently, and each child state may take a different transition in response to the event. (Similarly, one child state may take a transition in response to an event, while another child ignores it.) When all of the children reach final states, the <parallel> element itself is considered to be in a final state, and a completion event done.state._id_ is generated, where _id_ is the id of the <parallel> element.

Transitions _within_ the individual child elements operate normally. However whenever a transition is taken with a target _outside_ the <parallel> element, the <parallel> element and all of its child elements are exited and the corresponding <onexit> handlers are executed. The handlers for the child elements execute first, in document order, followed by those of the parent <parallel> element, followed by an action expression in the <transition> element, and then the <onentry> handlers in the "target" state.

In the following example, parallel state 'p' has two children S1 and S2. Suppose a transition takes S1's child S12 as a target. (Note that this is permitted even though S12 is not the default initial state for S1 and that S11 is not, in fact, visited in the course of this example). Upon this transition, the state machine, in addition to entering S1 and S12, will also enter S1's parallel sibling S2 and its initial state S21. Once the transition has been taken, p, S1, S2, S12, and S21 will all be active. If event 'e1' occurs, it will cause S12 to transition to S1Final, and S21 to transition to S22. Entering S1Final will cause the event done.state.S1 to be generated. At this point, S1 is in a final state, but S2 is still active. Now suppose event 'e2' occurs. This will cause S22 to transition to S2Final, and the event done.state.S2 will be generated. Furthermore, since all of p's children are now in final states, the event 'done.state.p' will be generated, which will cause the transition contained in p to be triggered, exiting the entire region.

```
&lt;parallel id="p"&gt;

    &lt;transition event="done.state.p" target="someOtherState"/&gt;

    &lt;state id="S1" initial="S11"&gt;
        &lt;state id="S11"&gt;
            &lt;transition event="e4" target="S12"/&gt;
        &lt;/state&gt;
        &lt;state id="S12"&gt;
            &lt;transition event="e1" target="S1Final"/&gt;
        &lt;/state&gt;
        &lt;final id="S1Final"/&gt;
    &lt;/state&gt;

    &lt;state id="S2" initial="S21"&gt;
        &lt;state id=S21"&gt;
            &lt;transition event="e1" target="S22"/&gt;
        &lt;/state&gt;
        &lt;state id="S22"&gt;
            &lt;transition event="e2" target="S2Final/&gt;
        &lt;/state&gt;
        &lt;final id="S2Final"/&gt;
    &lt;/state&gt;

&lt;/parallel&gt;
```

Note that the semantics of the <parallel> element does not call for multiple threads or truly concurrent processing. The children of <parallel> execute in parallel in the sense that they are all simultaneously active and each one independently selects transitions for any event that is received. However, the parallel children process the event in a defined, serial order, so no conflicts or race conditions can occur. See [_D Algorithm for SCXML Interpretation_](https://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation) for a detailed description of the semantics of <parallel> and the rest of SCXML.

#### 3.1.4 Initial, Final, and History States

In the presence of compound states, transitions no longer simply move from the current active state to a new active state, but from one set of active states to another. (See [_3.11 Legal State Configurations and Specifications_](https://www.w3.org/TR/scxml/#LegalStateConfigurations) for details.) If the target of a transition is an atomic state, the state machine will enter not only the atomic state, but also any of its ancestor states that are not already active. Conversely, a transition may take a compound state as its target. In this case, one of the compound state's children must also become active, but the transition does not specify which one. In this case we look at the target state's [_3.6 <initial>_](https://www.w3.org/TR/scxml/#initial) child which specifies the state's default initial state, that is, the child state to enter if the transition does not specify one. (If the default initial state is itself compound, the state machine will also enter its default initial state, and so on recursively until it reaches an atomic state.) The presence of default initial states provides a form of encapsulation, since a transition may select a compound state as its target without understanding its internal substate structure.

The default initial state of a compound state may also be specified via the 'initial' attribute. The only difference between the <initial> element and the 'initial' attribute is that the <initial> element contains a <transition> element which may in turn contain executable content which will be executed before the default state is entered. If the 'initial' attribute is specified instead, the specified state will be entered, but no executable content will be executed. (If neither the <initial> child or the 'initial' element is specified, the default initial state is the first child state in document order.) As an example, suppose that parent state S contains child states S1 and S2 in that order. If S specifies S1 as its default initial state via the 'initial' attribute (or fails to specify any initial state), then any transition that specifies S as its target will result in the state machine entering S1 as well as S. In this case, the result is exactly the same as if the transition had taken S1 as its target. If, on the other hand, S specifies S1 as its default initial state via an <initial> element containing a <transition> with S1 as its target, the <transition> can contain executable content which will execute before the default entry into S1. In this case, there is a difference between a transition that takes S as its target and one that takes S1 as its target. In the former case, but not in the latter, the executable content inside the <initial> transition will be executed.

A compound state may also have final and history states as children. [_3.7 <final>_](https://www.w3.org/TR/scxml/#final) is used to signify that the parent state is in some sense "done" with its processing. When a state machine enters a <final> substate of a compound state, the parent state remains active, but the event "done.state._id_" is generated, where _id_ is the state id of the parent state. This event can trigger a transition in any ancestor state (including the parent). If the transition takes a target outside the parent state, the "done.state._id_" event in effect serves as a signal that it is time to leave the parent state. [_3.10 <history>_](https://www.w3.org/TR/scxml/#history) allows for pause and resume semantics in compound states. Before the state machine exits a compound state, it records the state's active descendants. If the 'type' attribute of the <history> state is set to "deep", the state machine saves the state's full active descendant configuration, down to the atomic descendant(s). If 'type' is set to "shallow", the state machine remembers only which immediate child was active. After that, if a transition takes a <history> child of the state as its target, the state machine re-enters not only the parent compound state but also the state(s) in the saved configuration. Thus a transition with a deep history state as its target returns to exactly where the state was when it was last exited, while a transition with a shallow history state as a target re-enters the previously active child state, but will enter the child's default initial state (if the child is itself compound.)

#### 3.1.5 'Type' and Transitions

In the case of a transition located in a compound state, the 'type' attribute is significant. The behavior of a transition with 'type' of "external" (the default) is defined in terms of the transition's source state (which is the state that contains the transition), the transition's target state(or states), and the [Least Common Compound Ancestor (LCCA)](https://www.w3.org/TR/scxml/#LCCA) of the source and target states (which is the closest compound state that is an ancestor of all the source and target states). When a transition is taken, the state machine will exit all active states that are proper descendants of the LCCA, starting with the innermost one(s) and working up to the immediate descendant(s) of the LCCA. (A 'proper descendant' of a state is a child, or a child of a child, or a child of a child of a child, etc.) Then the state machine enters the target state(s), plus any states that are between it and the LCCA, starting with the outermost one (i.e., the immediate descendant of the LCCA) and working down to the target state(s). As states are exited, their <onexit> handlers are executed. Then the executable content in the transition is executed, followed by the <onentry> handlers of the states that are entered. If the target state(s) of the transition is not atomic, the state machine will enter their default initial states recursively until it reaches an atomic state(s).

In the example below, assume that state s11 is active when event 'e' occurs. The source of the transition is state s1, its target is state s21, and the LCCA is state S. When the transition is taken, first state S11 is exited, then state s1, then state s2 is entered, then state s21. Note that the LCCA S is neither entered nor exited. For more details see [_3.13 Selecting and Executing Transitions_](https://www.w3.org/TR/scxml/#SelectingTransitions) and [_D Algorithm for SCXML Interpretation_](https://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation).

```
&lt;state id="S" initial="s1"&gt;
   &lt;state id="s1" initial="s11"&gt;
      &lt;onexit&gt;
         &lt;log expr="'leaving s1'"/&gt;
     &lt;/onexit&gt;

     &lt;state id="s11"&gt;
        &lt;onexit&gt;
           &lt;log expr="'leaving s11'"/&gt;
        &lt;/onexit&gt;
     &lt;/state&gt;

     &lt;transition event="e" target="s21"&gt;
        &lt;log expr="'executing transition'"/&gt;
     &lt;/transition&gt;

   &lt;/state&gt;

   &lt;state id="s2" initial="s21"&gt;
      &lt;state id="s21"&gt;
         &lt;onentry&gt;
            &lt;log expr="'entering s21'"/&gt;
         &lt;/onentry&gt;
      &lt;/state&gt;
      &lt;onentry&gt;
         &lt;log expr="'entering s2'"/&gt;
      &lt;/onentry&gt;
   &lt;/state&gt;

   &lt;onentry&gt;
     &lt;log expr="'entering S'"/&gt;
   &lt;onentry&gt;
   &lt;onexit&gt;
     &lt;log expr="'leaving S'"/&gt;
   &lt;onexit&gt;
&lt;/state&gt;

==== log output will be ======&gt;

leaving s11
leaving s1
executing transition
entering s2
entering s21
```

The behavior of transitions with 'type' of "internal" is identical, except in the case of a transition whose source state is a compound state and whose target(s) is a descendant of the source. In such a case, an internal transition will not exit and re-enter its source state, while an external one will, as shown in the example below.

```
&lt;state id="S" initial="s1"&gt;
   &lt;state id="s1" initial="s11"&gt;
      &lt;onentry&gt;
        &lt;log expr="entering S1"/&gt;
        &lt;/onentry&gt;
      &lt;onexit&gt;
         &lt;log expr="'leaving s1'"/&gt;
     &lt;/onexit&gt;

     &lt;state id="s11"&gt;
       &lt;onentry&gt;
        &lt;log expr="entering s11"/&gt;
       &lt;/onentry&gt;
        &lt;onexit&gt;
           &lt;log expr="'leaving s11'"/&gt;
        &lt;/onexit&gt;
     &lt;/state&gt;

     &lt;transition event="e" target="s11" type="internal"&gt;
        &lt;log expr="'executing transition'"/&gt;
     &lt;/transition&gt;

   &lt;/state&gt;



==== log output will be ======&gt;

leaving s11
executing transition
entering s11

=== if transition were external, log output would be ====&gt;

leaving s11
leaving s1
executing transition
entering s1
entering s11

```

If the 'target' on a <transition> is omitted, then the value of 'type' does not have any effect and taking the transition does not change the state configuration but does invoke the executable content that is included in the transition. Note that this is different from a <transition> whose 'target' is its source state. In the latter case, the state is exited and reentered, triggering execution of its <onentry> and <onexit> executable content.

### 3.3 <state>

\[This section is normative.\]

Holds the representation of a state.

#### 3.3.2 Children

- <onentry> Optional element holding executable content to be run upon entering this <state>. Occurs 0 or more times. See [_3.8 <onentry>_](https://www.w3.org/TR/scxml/#onentry)
- <onexit> Optional element holding executable content to be run when exiting this <state>. Occurs 0 or more times. See [_3.9 <onexit>_](https://www.w3.org/TR/scxml/#onexit)
- <transition> Defines an outgoing transition from this state. Occurs 0 or more times. See [_3.5 <transition>_](https://www.w3.org/TR/scxml/#transition)
- <initial> In states that have substates, an optional child which identifies the default initial state. Any transition which takes the parent state as its target will result in the state machine also taking the transition contained inside the <initial> element. See [_3.6 <initial>_](https://www.w3.org/TR/scxml/#initial)
- <state> Defines a sequential substate of the parent state. Occurs 0 or more times.
- <parallel> Defines a parallel substate. Occurs 0 or more times. See [_3.4 <parallel>_](https://www.w3.org/TR/scxml/#parallel)
- <final>. Defines a final substate. Occurs 0 or more times. See [_3.7 <final>_](https://www.w3.org/TR/scxml/#final).
- <history> A child pseudo-state which records the descendant state(s) that the parent state was in the last time the system transitioned _from_ the parent. May occur 0 or more times. See [_3.10 <history>_](https://www.w3.org/TR/scxml/#history).
- <datamodel> Defines part or all of the data model. Occurs 0 or 1 times. See [_5.2 <datamodel>_](https://www.w3.org/TR/scxml/#datamodel)
- <invoke> Invokes an external service. Occurs 0 or more times. See [_6.4 <invoke>_](https://www.w3.org/TR/scxml/#invoke) for details.

\[Definition: An _atomic state_ is a <state> that has no <state>, <parallel> or <final> children.\]

\[Definition: A _compound state_ is a <state> that has <state>, <parallel>, or <final> children (or a combination of these).\]

\[Definition: The _default initial state(s)_ of a compound state are those specified by the 'initial' attribute or <initial> element, if either is present. Otherwise it is the state's first child state in document order. \]

In a conformant SCXML document, a compound state _MAY_ specify either an "initial" attribute or an <initial> element, but not both. See [_3.6 <initial>_](https://www.w3.org/TR/scxml/#initial) for a discussion of the difference between the two notations.

### 3.7 <final>

\[This section is normative.\]

<final> represents a final state of an <scxml> or compound <state> element.

#### 3.7.2 Children

- <onentry> Optional element holding executable content to be run upon entering this state. Occurs 0 or more times. See [_3.8 <onentry>_](https://www.w3.org/TR/scxml/#onentry) for details.
- <onexit> Optional element holding executable content to be run when exiting this state. Occurs 0 or more times. See [_3.9 <onexit>_](https://www.w3.org/TR/scxml/#onexit) for details.
- <donedata> Optional element specifying data to be included in the done.state._id_ or done.invoke._id_ event. See [_5.5 <donedata>_](https://www.w3.org/TR/scxml/#donedata) for details.

When the state machine enters the <final> child of a <state> element, the SCXML Processor _MUST_ generate the event done.state._id_ after completion of the <onentry> elements, where _id_ is the id of the parent state. Immediately thereafter, if the parent <state> is a child of a <parallel> element, and all of the <parallel>'s other children are also in final states, the Processor _MUST_ generate the event done.state._id_ where _id_ is the id of the <parallel> element.

When the state machine reaches the <final> child of an <scxml> element, it _MUST_ terminate. See [_D Algorithm for SCXML Interpretation_](https://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation) for details. If the SCXML session was triggered as the result by an <invoke> element in another session, the SCXML processor _MUST_ generate the event done.invoke._id_ after termination and return it to the other session, where _id_ is the unique identifier generated when the <invoke> element was executed. See [_6.4 <invoke>_](https://www.w3.org/TR/scxml/#invoke) for details.

### 3.10 <history>

The <history> pseudo-state allows a state machine to remember its state configuration. A <transition> taking the <history> state as its target will return the state machine to this recorded configuration.

#### 3.10.2 Children

- <transition> A transition whose 'target' specifies the default history configuration. Occurs once. In a conformant SCXML document, this transition _MUST NOT_ contain 'cond' or 'event' attributes, and _MUST_ specify a non-null 'target' whose value is a valid state specification (see [_3.11 Legal State Configurations and Specifications_](https://www.w3.org/TR/scxml/#LegalStateConfigurations)). This transition _MAY_ contain executable content. If 'type' is "shallow", then the 'target' of this <transition> _MUST_ contain only immediate children of the parent state. Otherwise it _MUST_ contain only descendants of the parent. Occurs once. (Note that under the definition of a legal state specification, if the parent of the history element is <state> and the default state specification contains a multiple states, then, in a conformant SCXML document, the 'type' of the history element _MUST_ be "deep" and the states _MUST_ be atomic descendants of a <parallel> element that is itself a descendant of the parent <state> element.)

If the 'type' of a <history> element is "shallow", the SCXML processor _MUST_ record the immediately active children of its parent before taking any transition that exits the parent. If the 'type' of a <history> element is "deep", the SCXML processor _MUST_ record the active atomic descendants of the parent before taking any transition that exits the parent. After the parent state has been visited for the first time, for each <history> element, we define the set of states that the processor has recorded to be the 'stored state configuration' for that history state. We also define the states specified by the 'target' of the <history> element's <transition> child to be the 'default stored state configuration' for that element. If a transition is executed that takes the <history> state as its target, the behavior depends on whether the parent state has been visited before. If it has, the SCXML processor _MUST_ behave as if the transition had taken the stored state configuration for that history state as its target. If it has not, the SCXML processor _MUST_ behave as if the transition had taken the default stored state configuration for that history state as its target. The Process _MUST_ execute any executable content in the transition after the parent state's onentry handlers, and, in the case where the history pseudo-state is the target of an <initial> transition, the executable content inside the <initial> transition. (Note that in a conformant SCXML document, a <state> or <parallel> element _MAY_ have both "deep" and "shallow" <history> children.)

### 3.11 Legal State Configurations and Specifications

\[This section is normative.\]

\[Definition: A <state> or <parallel> element is _active_ if it has been entered by a transition and has not subsequently been exited.\]

\[Definition: The _state configuration_ of a state machine is the set of currently active states. \]

An SCXML document places the state machine in an initial state configuration at initialization time (via the 'initial' attribute of the <scxml> element). Each transition that the state machine takes thereafter places the state machine in another state configuration (which need not be distinct from the former one.) A conformant SCXML document _MUST_ place the state machine only in legal state configurations, where a legal state configuration is one that meets the following conditions:

- The configuration contains exactly one child of the <scxml> element.
- The configuration contains one or more atomic states.
- When the configuration contains an atomic state, it contains all of its <state> and <parallel> ancestors.
- When the configuration contains a non-atomic <state>, it contains one and only one of the state's children.
- If the configuration contains a <parallel> state, it contains all of its children.

It follows from this definition that if a state machine is in more than one atomic state, the atomic states can be traced back through a chain of <state> or <parallel> ancestors to a single <parallel> ancestor.

The 'target' attribute of a <transition> (or the 'initial' attribute of a <state> or <scxml> element) do not in the general case specify a full legal state configuration since 1) they can contain <parallel> or non-atomic <state> elements 2) they do not contain the ancestors of the states in the list. We therefore define a legal state specification to be a set of states such that 1) no state is an ancestor of any other state on the list, and 2) a full legal state configuration results when all ancestors and default initial descendants have been added. (Note that the process of adding default initial descendants is recursive, since the 'initial' value may itself be non-atomic.) In a conformant SCXML document, the value of an 'initial' attribute or the 'target' of a <transition> _MUST_ either be empty or contain a legal state specification.

In a conformant SCXML document, there is an additional requirement on the value of the 'initial' attribute of a <state> and on the 'target' of a <transition> inside an <initial> or <history> element: all the states _MUST_ be descendants of the containing <state> or <parallel> element.

### 3.12 SCXML Events

\[This section is normative.\]

Events are one of the basic concepts in SCXML since they drive most transitions. The internal structure of events is platform-specific as long as the following external interface is observed:

- The SCXML processor _MUST_ make the data contained in an event accessible via the '\_event' variable, as specified in [_5.10 System Variables_](https://www.w3.org/TR/scxml/#SystemVariables).
- The SCXML processor _MUST_ make the event's name accessible via the '\_event' variable, as specified in [_5.10 System Variables_](https://www.w3.org/TR/scxml/#SystemVariables). The SCXML processor _MUST_ use this same name value to match against the 'event' attribute of transitions.

For the most part, the set of events raised during the execution of an SCXML document is application-specific and generated under author control by use of the <raise> and <send> elements. However, certain events are mandatory and generated automatically by the interpreter. These are described in [_3.12.3 List of Errors and Events_](https://www.w3.org/TR/scxml/#errorsAndEvents). Platforms _MAY_ extend the names of these automatically generated events by adding a suffix. For example, a platform could extend done.state._id_ with a timestamp suffix and generate done.state._id.timestamp_ instead. Because any prefix of done.state._id_ is also a prefix of done.state._id.timestamp_, any transition that matches the former event will also match the latter.

#### 3.12.1 Event Descriptors

Like an event name, an event descriptor is a series of alphanumeric characters segmented into tokens by the "." character. The 'event' attribute of a transition consists of one or more such event descriptors separated by spaces.

\[Definition: A transition _matches_ an event if at least one of its event descriptors matches the event's name. \]

\[Definition: An event descriptor _matches_ an event name if its string of tokens is an exact match or a prefix of the set of tokens in the event's name. In all cases, the token matching is case sensitive. \]

For example, a transition with an 'event' attribute of "error foo" will match event names "error", "error.send", "error.send.failed", etc. (or "foo", "foo.bar" etc.) but would not match events named "errors.my.custom", "errorhandler.mistake", "error.send" or "foobar".

For compatibility with CCXML, and to make the prefix matching possibly more clear to a reader of the SCXML document, an event descriptor _MAY_ also end with the wildcard '.\*', which matches zero or more tokens at the end of the processed event's name. Note that a transition with 'event' of "error", one with "error.", and one with "error.\*" are functionally equivalent since they are token prefixes of exactly the same set of event names.

An event designator consisting solely of "\*" can be used as a wildcard matching any sequence of tokens, and thus any event. Note that this is different from a transition lacking the 'event' attribute altogether. Such an eventless transition does not match any event, but will be taken whenever its 'cond' attribute evaluates to 'true'. As shown in [_D Algorithm for SCXML Interpretation_](https://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation), the SCXML interpreter will check for such eventless transitions when it first enters a state, before it looks for transitions driven by internal or external events.

#### 3.12.3 List of Errors and Events

The following events are generated automatically by the SCXML implementation under conditions defined elsewhere in this document.

| Name                | Description                                                                                                                     | Defined in                                                  | See also                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| done.state._id_     | Indicates that the state machine has entered a final substate of state _id_.                                                    | [_3.7 <final>_](https://www.w3.org/TR/scxml/#final)         | [_3.1 Introduction_](https://www.w3.org/TR/scxml/#CoreIntroduction)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| done.invoke._id_    | Indicates that the invoked process with invokeid _id_ has completed processing.                                                 | [_6.4 <invoke>_](https://www.w3.org/TR/scxml/#invoke)       | [_3.7 <final>_](https://www.w3.org/TR/scxml/#final), exitInterpreter procedure in [_D Algorithm for SCXML Interpretation_](https://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| error.communication | Indicates that an error has occurred while trying to communicate with an external entity.                                       | [_3.12.2 Errors_](https://www.w3.org/TR/scxml/#ErrorEvents) | [_6.2 <send>_](https://www.w3.org/TR/scxml/#send), [_C.1 SCXML Event I/O Processor_](https://www.w3.org/TR/scxml/#SCXMLEventProcessor), [_C.2 Basic HTTP Event I/O Processor_](https://www.w3.org/TR/scxml/#BasicHTTPEventProcessor)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| error.execution     | Indicates that an error internal to the execution of the document has occurred, such as one arising from expression evaluation. | [_3.12.2 Errors_](https://www.w3.org/TR/scxml/#ErrorEvents) | [_4.6 <foreach>_](https://www.w3.org/TR/scxml/#foreach), [_5.4 <assign>_](https://www.w3.org/TR/scxml/#assign), [_5.7 <param>_](https://www.w3.org/TR/scxml/#param), [_5.9.1 Conditional Expressions_](https://www.w3.org/TR/scxml/#ConditionalExpressions), [_5.9.2 Location Expressions_](https://www.w3.org/TR/scxml/#LocationExpressions), [_5.9.3 Legal Data Values and Value Expressions_](https://www.w3.org/TR/scxml/#ValueExpressions), [_5.9.4 Errors in Expressions_](https://www.w3.org/TR/scxml/#ErrorsinExpressions), [_5.10 System Variables_](https://www.w3.org/TR/scxml/#SystemVariables), [_6.2 <send>_](https://www.w3.org/TR/scxml/#send), [_B.2.4 Location Expressions_](https://www.w3.org/TR/scxml/#ecma_location_expressions), [_B.2.7 <assign>_](https://www.w3.org/TR/scxml/#ecma_assign) |
| error.platform      | Indicates that a platform- or application-specific error has occurred.                                                          | [_3.12.2 Errors_](https://www.w3.org/TR/scxml/#ErrorEvents) |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

### 3.13 Selecting and Executing Transitions

\[This section is normative.\]

To simplify the following definitions, we introduce the event NULL. NULL has no name and is used only in these definitions. It never occurs in the event queues of an SCXML Processor. All other events have names and are distinct from NULL. (In effect, NULL is a pseudo-event that is used in these definitions as a trigger for eventless transitions.)

\[Definition: A transition T is _enabled_ by named event E in atomic state S if a) T's source state is S or an ancestor of S,and b) T matches E's name (see [_3.12.1 Event Descriptors_](https://www.w3.org/TR/scxml/#EventDescriptors)) and c) T lacks a 'cond' attribute or its 'cond' attribute evaluates to "true". A transition is _enabled_ by NULL in atomic state S if a) T lacks an 'event' attribute, and b) T's source state is S or an ancestor of S and c) T lacks an 'cond' attribute or its 'cond' attribute evaluates to "true". (Note that such a transition can never be enabled by any named event.)\]

\[Definition: The _source state_ of a transition is the <state> or <parallel> element that it occurs in. The _effective target state(s)_ of the transition is the state or set of states specified by its 'target' attribute, with any history states being replaced by the corresponding stored state configuration or default stored state configuration. The _complete target set_ of a transition consists of all the states that will be active after the transition is taken. It contains the effective target states of the transition plus all their ancestors, expanded by the recursive application of the following two operations: 1) if any <parallel> element is a member of the set, any of its children that are not members of the set must be added 2) if any compound <state> is in the set and none of its children is in the set, its default initial state(s) are added to the set. Any state whose child(ren) are added to the complete target set by clause 2 is called a _default entry state_. \]

\[Definition: The _exit set_ of a transition in configuration C is the set of states that are exited when the transition is taken when the state machine is in C. If the transition does not contain a 'target', its exit set is empty. Otherwise (i.e., if the transition contains a 'target'), if its 'type' is "external", its exit set consists of all active states in C that are proper descendants of the [Least Common Compound Ancestor (LCCA)](https://www.w3.org/TR/scxml/#LCCA) of the source and target states. Otherwise, if the transition has 'type' "internal", its source state is a compound state, and all its target states are proper descendants of its source state, the exit set consists of all active states in C that are proper descendants of its source state. (If a transition has 'type' of "internal", but its source state is not compound or its target states are not all proper descendants of its source state, its exit set is defined as if it had 'type' of "external". The exit set of a set of transitions is the union of the exit sets of the individual transitions. \]

\[Definition: The _entry set_ of a transition in configuration C is the set of states that are entered when the transition is taken. If a transition does not contain a 'target', its entry set is empty. Otherwise, it consists of all members of the transition's complete target set that that are not currently active or are in the exit set. (Thus the entry set consists of all members of the transition's complete target set that will not be active once the states in the exit set have been exited.) The entry set of a set of transitions is the union of the entry sets of the individual transitions.\]

\[Definition: A transition T is _optimally enabled_ by event E in atomic state S if a) T is enabled by E in S and b) no transition that precedes T in document order in T's source state is enabled by E in S and c) no transition is enabled by E in S in any descendant of T's source state.\]

\[Definition: Two transitions T1 and T2 _conflict_ in state configuration C if their exit sets in C have a non-null intersection.\]

N.B. If two transitions conflict, then taking them both may lead to an illegal configuration. Hence, only one of the transitions may safely be taken. In order to resolve conflicts between transitions, we assign priorities to transitions as follows: let transitions T1 and T2 conflict, where T1 is optimally enabled in atomic state S1, and T2 is optimally enabled in atomic state S2, where S1 and S2 are both active. We say that T1 has a higher priority than T2 if a) T1's source state is a descendant of T2's source state, or b) S1 precedes S2 in document order.

\[Definition: The _optimal transition set_ enabled by event E in state configuration C is the largest set of transitions such that a) each transition in the set is optimally enabled by E in an atomic state in C b) no transition conflicts with another transition in the set c) there is no optimally enabled transition outside the set that has a higher priority than some member of the set. \]

\[Definition: A _microstep_ consists of the execution of the transitions in an optimal enabled transition set.\]

\[Definition: A _macrostep_ is a series of one or more microsteps ending in a configuration where the internal event queue is empty and no transitions are enabled by NULL. \]

To execute a microstep, the SCXML Processor _MUST_ execute the transitions in the corresponding optimal enabled transition set. To execute a set of transitions, the SCXML Processor _MUST_ first exit all the states in the transitions' exit set in [exit order](https://www.w3.org/TR/scxml/#exitOrder). It _MUST_ then execute the executable content contained in the transitions in document order. It _MUST_ then enter the states in the transitions' entry set in [entry order](https://www.w3.org/TR/scxml/#entryOrder).

To exit a state, the SCXML Processor _MUST_ execute the executable content in the state's <onexit> handler. Then it _MUST_ cancel any ongoing invocations that were triggered by that state. Finally, the Processor _MUST_ remove the state from the active state's list.

To enter a state, the SCXML Processor _MUST_ add the state to the active state's list. Then it _MUST_ execute the executable content in the state's <onentry> handler. If the state is a default entry state and has an <initial> child, the SCXML Processor _MUST_ then execute the executable content in the <initial> child's <transition>.

At startup, the SCXML Processor _MUST_ place the state machine in the configuration specified by the 'initial' attribute of the <scxml> element.

After entering the initial configuration, and after executing each microstep, the SCXML Processor _MUST_ check the state configuration for <final> states that it has entered during the microstep. If it has entered a <final> state that is a child of <scxml>, it _MUST_ halt processing. If it has entered a <final> state that is a child of a compound state, it _MUST_ generate the event done.state._id_, where _id_ is the id of the compound state. If the compound state is itself the child of a <parallel> element, and all the <parallel> element's other children are in final states, the Processor _MUST_ generate the event done.state._id_, where _id_ is the id of the <parallel> elements.

After checking the state configuration, the Processor _MUST_ select the optimal transition set enabled by NULL in the current configuration. If the set is not empty, it _MUST_ execute it as a microstep. If the set is empty, the Processor _MUST_ remove events from the internal event queue until the queue is empty or it finds an event that enables a non-empty optimal transition set in the current configuration. If it finds such a set, the processor _MUST_ then execute it as a microstep. (Otherwise the internal event queue is empty and the Processor has completed a macrostep.)

After completing a macrostep, the SCXML Processor _MUST_ execute in document order the <invoke> handlers in all states that have been entered since the completion of the last macrostep. Then the Processor _MUST_ remove events from the external event queue, waiting till events appear if necessary, until it finds one that enables a non-empty optimal transition set in the current configuration. The Processor _MUST_ then execute that set as a microstep.

## 4 Executable Content

### 4.3 <if>

\[This section is normative.\]

<if> is a container for conditionally executed elements.

#### 4.3.2 Children

- <elseif> Occurs 0 or more times. See [_4.4 <elseif>_](https://www.w3.org/TR/scxml/#elseif)
- <else> Occurs 0 or 1 times. See [_4.5 <else>_](https://www.w3.org/TR/scxml/#else)
- The other children of <if> consist of executable content. Note that since <if> itself is executable content, nested <if> statements are allowed.

The behavior of <if> is defined in terms of partitions of executable content. The first partition consists of the executable content between the <if> and the first <elseif>, <else> or </if> tag. Each <elseif> tag defines a partition that extends from it to the next <elseif>, <else> or </if> tag. The <else> tag defines a partition that extends from it to the closing </if> tag. In a conformant SCXML document, a partition _MAY_ be empty. In a conformant SCXML document, <else> _MUST_ occur after all <elseif> tags.

When the <if> element is executed, the SCXML processor _MUST_ execute the first partition in document order that is defined by a tag whose 'cond' attribute evaluates to true, if there is one. Otherwise, it _MUST_ execute the partition defined by the <else> tag, if there is one. Otherwise it _MUST NOT_ execute any of the executable content.

Here is an example:

```
&lt;if cond="cond1"&gt;
  &lt;!-- selected when "cond1" is true --&gt;
&lt;elseif cond="cond2"/&gt;
  &lt;!-- selected when "cond1" is false and "cond2" is true --&gt;
&lt;elseif cond="cond3"/&gt;
  &lt;!-- selected when "cond1" and "cond2" are false and "cond3" is true --&gt;
&lt;else/&gt;
  &lt;!-- selected when "cond1", "cond2", and "cond3" are false --&gt;
&lt;/if&gt;

```

## 5 Data Model and Data Manipulation

### 5.1 Introduction

\[This section is informative.\]

The Data Model offers the capability of storing, reading, and modifying a set of data that is internal to the state machine. This specification does not mandate any specific data model, but instead defines a set of abstract capabilities that can be realized by various languages, such as ECMAScript or XML/XPath. Implementations may choose the set of data models that they support. In addition to the underlying data structure, the data model defines a set of expressions as described in [_5.9 Expressions_](https://www.w3.org/TR/scxml/#Expressions). These expressions are used to refer to specific locations in the data model, to compute values to assign to those locations, and to evaluate boolean conditions. Finally, the data model includes a set of system variables, as defined in [_5.10 System Variables_](https://www.w3.org/TR/scxml/#SystemVariables), which are automatically maintained by the SCXML processor.

The data model is defined via the [_5.2 <datamodel>_](https://www.w3.org/TR/scxml/#datamodel) element, which contains zero or more [_5.3 <data>_](https://www.w3.org/TR/scxml/#data) elements, each of which defines a single data element and assigns an initial value to it. These values may be specified in-line or loaded from an external source. They can then be updated via the [_5.4 <assign>_](https://www.w3.org/TR/scxml/#assign) element. The [_5.5 <donedata>_](https://www.w3.org/TR/scxml/#donedata), [_5.6 <content>_](https://www.w3.org/TR/scxml/#content) , and [_5.7 <param>_](https://www.w3.org/TR/scxml/#param) elements can be used to incorporate data into communications with external entities. Finally, the [_5.8 <script>_](https://www.w3.org/TR/scxml/#script) element permits the incorporation of a scripting language.

The interpretation of these elements depends on the data model in question, and not all elements are supported in all data models. For the details of specific data models, see [_B Data Models_](https://www.w3.org/TR/scxml/#profiles).

### 5.3 <data>

\[This section is normative.\]

The <data> element is used to declare and populate portions of the data model.

#### 5.3.2 Children

The children of the <data> element represent an in-line specification of the value of the data object.

In a conformant SCXML document, a <data> element _MAY_ have either a 'src' or an 'expr' attribute, but _MUST NOT_ have both. Furthermore, if either attribute is present, the element _MUST NOT_ have any children. Thus 'src', 'expr' and children are mutually exclusive in the <data> element.

The SCXML Processor _MUST_ use any values provided by the environment at instantiation time in place of those contained in the top-level <data> elements. (Top-level data elements are those that are children of the <datamodel > element that is a child of <scxml>). The manner in which the environment specifies these overriding values is platform-dependent.

If the 'expr' attribute is present, the Platform _MUST_ evaluate the corresponding expression at the time specified by the 'binding' attribute of <scxml> and _MUST_ assign the resulting value as the value of the data element. If the 'src' attribute is present, the Platform _MUST_ fetch the specified object at the time specified by the 'binding' attribute of <scxml> and _MUST_ assign it as the value of the data element. If child content is specified, the Platform _MUST_ assign it as the value of the data element at the time specified by the 'binding' attribute of <scxml>. Note that in the latter two cases, the interpretation of the object or content will depend on the data model. See [_B Data Models_](https://www.w3.org/TR/scxml/#profiles) for details. If the value specified for a <data> element (by 'src', children, or the environment) is not a legal data value, the SCXML Processor _MUST_ raise place error.execution in the internal event queue and _MUST_ create an empty data element in the data model with the specified id.

Implementations _MAY_ predeclare and predefine variables in the data model. However, conformant SCXML implementations _SHOULD NOT_ assume the existence of any predeclared or predefined variables (i.e., ones not explicitly defined by <data>).

Note that this specification does not define any way to modify the data model except by<assign>, <finalize>, and possibly platform-specific elements of executable content. In particular, no means is defined for external entities to modify the data model. In this sense the data model is local to the SCXML session and the SCXML Processor checks for eventless transitions (i.e. ones that are triggered based only on the state of the data model) only after entering a state or processing an event. However in some deployments it may be possible for external entities to modify the data model. For example, if SCXML is implemented in JavaScript in a browser, the scope of a document's data model is always accessible through the main window object and thus JavaScript code elsewhere in the window can modify the data model independent of the SCXML interpretation algorithm. Such a situation can lead to race conditions and unpredictable behavior

### 5.4 <assign>

\[This section is normative.\]

The <assign> element is used to modify the data model.

A conformant SCXML document _MUST_ specify either "expr" or children of <assign>, but not both.

Assignment to a data model is done by using a location expression to denote the part of the data model where the insertion is to be made. If the location expression does not denote a valid location in the data model or if the value specified (by 'expr' or children) is not a legal value for the location specified, the SCXML Processor _MUST_ place the error 'error.execution' in the internal event queue. Otherwise, the SCXML Processor _MUST_ place the specified value at the specified location. Note that the nature of the insertion and the definition of a legal value depends on the data model language used. Note also that data models _MAY_ support additional attributes for <assign> beyond those specified here. See [_B Data Models_](https://www.w3.org/TR/scxml/#profiles) for details.

### 5.10 System Variables

\[This section is normative.\]

The SCXML Processor _MUST_ maintain a protected portion of the data model containing information that can be useful to applications. We refer to the items in this special part of the data model as 'system variables'. Implementations _MUST_ provide the following system variables, and _MAY_ support others.

- _\_event_. The SCXML Processor _MUST_ use the variable '\_event' to hold a structure containing the current event's name and any data contained in the event (see [_5.10.1 The Internal Structure of Events_](https://www.w3.org/TR/scxml/#InternalStructureofEvents). The exact nature of the structure depends on the data model being used. See [_B Data Models_](https://www.w3.org/TR/scxml/#profiles) for details. The SCXML Processor _MUST_ bind the \_event variable when an event is pulled off the internal or external event queue to be processed, and _MUST_ keep the variable bound to that event until another event is processed. (It follows that when an application is testing the 'cond' attribute of a <transition> element that contains an 'event' attribute, \_event will be bound to the event that the transition is being matched against. If the transition is selected to be executed, \_event will remain bound to that event in the <onexit> handlers of the states being exited, the executable content of the transition itself, and the <onentry> handlers of the states being entered. In the case of <transition> elements that do not contain an 'event' attribute and the <onexit> and <onentry> handlers of any states that are exited or entered by such transitions, the \_event variable will not have a easily predictable value since the transition is not being driven by an event. In these cases, \_event will be bound to the last event that was matched against a transition.) The SCXML Processor _MUST NOT_ bind \_event at initialization time until the first event is processed. Hence \_event is unbound when the state machine starts up. If the data in the event is not a legal instance of the data model language, and the Processor cannot translate it into one, then the Processor _MUST_ place the error 'error.execution' in the internal event queue at the point at which it attempts to bind \_event. In this case, the Processor _MUST_ leave the event data part of the \_event structure unbound. (Note that the event's name will still be available, however and that processing of both the original event and the error event will proceed as usual.)
- _\_sessionid_. The SCXML Processor _MUST_ bind the variable \_sessionid at load time to the system-generated id for the current SCXML session. (This is of type NMTOKEN.) The Processor _MUST_ keep the variable bound to this value until the session terminates.
- _\_name_. The SCXML Processor _MUST_ bind the variable \_name at load time to the value of the 'name' attribute of the <scxml> element. The Processor _MUST_ keep the variable bound to this value until the session terminates.
- _\_ioprocessors_. The SCXML Processor _MUST_ bind the variable \_ioprocessors to a set of values, one for each Event I/O Processor that it supports. The syntax to access it depends on the data model. See [_B Data Models_](https://www.w3.org/TR/scxml/#profiles) for details. The nature of the values associated with the individual Event I/O Processors depends on the Event I/O Processor in question. See [_C Event I/O Processors_](https://www.w3.org/TR/scxml/#eventioprocessors) for details. The Processor _MUST_ keep the variable bound to this set of values until the session terminates.
- _\_x_. The variable \_x is the root element for platform-specific system variables. The Processor _MUST_ place all platform-specific system variables underneath it. The exact structure of the platform-specific variables depends on the data model. For example, in the ECMAScript data model [_B.2 The ECMAScript Data Model_](https://www.w3.org/TR/scxml/#ecma-profile), '\_x' will be a top-level ECMAScript object and the platform-specific system variables will be its properties.

The set of system variables may be expanded in future versions of this specification. Variable names beginning with '\_' are reserved for system use. A conformant SCXML document _MUST NOT_ contain ids beginning with '\_' in the <data> element. Platforms _MUST_ place all platform-specific system variables under the '\_x' root.

The concrete realization of these variables in a specific data model depends on the language used. The Processor _MUST_ cause any attempt to change the value of a system variable to fail and _MUST_ place the error 'error.execution' on the internal event queue when such an attempt is made.

#### 5.10.1 The Internal Structure of Events

Events have an internal structure which is reflected in the \_event variable. This variable can be accessed to condition transitions (via boolean expressions in the 'cond' attribute) or to update the data model (via <assign>), etc.

The SCXML Processor _MUST_ ensure that the following fields are present in all events, whether internal or external.

- _name_. This is a character string giving the name of the event. The SCXML Processor _MUST_ set the name field to the name of this event. It is what is matched against the 'event' attribute of <transition>. Note that transitions can do additional tests by using the value of this field inside boolean expressions in the 'cond' attribute.
- _type_. This field describes the event type. The SCXML Processor _MUST_ set it to: "platform" (for events raised by the platform itself, such as error events), "internal" (for events raised by <raise> and <send> with target '\_internal') or "external" (for all other events).- _sendid_. If the sending entity has specified a value for this, the Processor _MUST_ set this field to that value (see [_C Event I/O Processors_](https://www.w3.org/TR/scxml/#eventioprocessors) for details). Otherwise, in the case of error events triggered by a failed attempt to send an event, the Processor _MUST_ set this field to the send id of the triggering <send> element. Otherwise it _MUST_ leave it blank.
- _origin_. This is a URI, equivalent to the 'target' attribute on the <send> element. For external events, the SCXML Processor _SHOULD_ set this field to a value which, when used as the value of 'target', will allow the receiver of the event to <send> a response back to the originating entity via the Event I/O Processor specified in 'origintype'. For internal and platform events, the Processor _MUST_ leave this field blank.
- _origintype_. This is equivalent to the 'type' field on the <send> element. For external events, the SCXML Processor _SHOULD_ set this field to a value which, when used as the value of 'type', will allow the receiver of the event to <send> a response back to the originating entity at the URI specified by 'origin'. For internal and platform events, the Processor _MUST_ leave this field blank.
- _invokeid_. If this event is generated from an invoked child process, the SCXML Processor _MUST_ set this field to the invoke id of the invocation that triggered the child process. Otherwise it _MUST_ leave it blank.
- _data_. This field contains whatever data the sending entity chose to include in this event. The receiving SCXML Processor _SHOULD_ reformat this data to match its data model, but _MUST NOT_ otherwise modify it. If the conversion is not possible, the Processor _MUST_ leave the field blank and _MUST_ place an error 'error.execution' in the internal event queue.

## 6 External Communications

### 6.1 Introduction

\[This section is informative.\]

The External Communications capability allows an SCXML session to send and receive events from external entities, and to invoke external services. [_6.2 <send>_](https://www.w3.org/TR/scxml/#send) provides "fire and forget" capability to deliver events and data to any destination, including other SCXML sessions. The 'delay' attribute allows for deferred event delivery and can be used to implement a timer. The details of event transport as well as the format of the event and data are determined by the Event I/O Processor selected. Each implementation will support one or more such processor, and the author of the SCXML markup can choose the one that is appropriate for the type of endpoint he is trying to reach.

[_6.4 <invoke>_](https://www.w3.org/TR/scxml/#invoke) offers a more tightly coupled form of communication, specifically the ability to trigger a platform-defined service and pass data to it. It and its child <finalize> are useful in states that model the behavior of an external service. The <invoke> element is executed after the state's <onentry> element and causes an instance of the external service to be created. The <param> and <content> elements and the 'namelist' attribute can be used to pass data to the service. Any events that are received by the state machine from the invoked component during the invocation are preprocessed by the <finalize> handler _before_ transitions are selected. The <finalize> code is used to normalize the form of the returned data and to update the data model before the transitions' "event" and "cond" clauses are evaluated.

When parallel states invoke the same external service concurrently, separate instances of the external service will be started. They can be distinguished by ids which are associated with them. Similarly, the ids contained in the events returned from the external services can be used to determine which events are responses to which invocation. Each event that is returned will be processed only by the <finalize> in the state that invoked it, but that event is then processed like any other event that the state machine receives. The finalize code can thus be thought of as a preprocessing stage that applies before the event is added to the event queue. Note that the event will be passed to all parallel states to check for transitions.

Since an invocation will be canceled when the state machine leaves the invoking state, it does not make sense to start an invocation in a state that will be exited immediately. Therefore the <invoke> element is executed upon entry into the state, but only _after_ checking for eventless transitions and transitions driven by pending internal events. If any such enabled transition is found , it is taken and the state is exited immediately, without triggering the invocation. Thus invocations are triggered only when the state machine has reached a stable configuration, i.e., one that it will be staying in while it waits for external events.

### 6.2 <send>

\[This section is normative.\]

#### 6.2.3 Children

- <param>. The SCXML Processor _MUST_ evaluate this element when the parent <send> element is evaluated and pass the resulting data to the external service when the message is delivered. Occurs 0 or more times. See [_5.7 <param>_](https://www.w3.org/TR/scxml/#param) for details.
- <content>. The SCXML Processor _MUST_ evaluate this element when the parent <send> element is evaluated and pass the resulting data to the external service when the message is delivered. Occurs 0 or 1 times. See [_5.6 <content>_](https://www.w3.org/TR/scxml/#content) for details.

A conformant SCXML document _MUST_ specify exactly one of 'event', 'eventexpr' and <content>. A conformant document _MUST NOT_ specify "namelist" or <param> with <content>.

The SCXML Processor _MUST_ include all attributes and values provided by <param> or 'namelist' even if duplicates occur.

If 'idlocation' is present, the SCXML Processor _MUST_ generate an id when the parent <send> element is evaluated and store it in this location. See [_3.14 IDs_](https://www.w3.org/TR/scxml/#IDs) for details.

If a delay is specified via 'delay' or 'delayexpr', the SCXML Processor _MUST_ interpret the character string as a time interval. It _MUST_ dispatch the message only when the delay interval elapses. (Note that the evaluation of the `send` tag will return immediately.) The Processor _MUST_ evaluate all arguments to <send> when the <send> element is evaluated, and not when the message is actually dispatched. If the evaluation of <send>'s arguments produces an error, the Processor _MUST_ discard the message without attempting to deliver it. If the SCXML session terminates before the delay interval has elapsed, the SCXML Processor _MUST_ discard the message without attempting to deliver it.

### 6.4 <invoke>

\[This section is normative.\]

The <invoke> element is used to create an instance of an external service.

#### 6.4.2 Children

- <param>. Element containing data to be passed to the external service. Occurs 0 or more times. See [_5.7 <param>_](https://www.w3.org/TR/scxml/#param).
- <finalize>. Element containing executable content to massage the data returned from the invoked component. Occurs 0 or 1 times. See [_6.5 <finalize>_](https://www.w3.org/TR/scxml/#finalize) for details.
- <content>. The SCXML Processor MUST evaluate this element when the parent <invoke> element is evaluated and pass the resulting data to the invoked service. Occurs 0 or 1 times. See [_5.6 <content>_](https://www.w3.org/TR/scxml/#content) for details.

Platforms _MUST_ support http://www.w3.org/TR/scxml/ as a value for the 'type' attribute. Platforms _MAY_ support http://www.w3.org/TR/voicexml21/, which indicates a VoiceXML 2.1 interpreter, http://www.w3.org/TR/voicexml30/, which indicates a VoiceXML 3.x interpreter, and http://www.w3.org/TR/ccxml/, which indicates a CCXML 1.0 interpreter. Platforms _MAY_ support additional values, but they _SHOULD_ assign them the URI of a description of the relevant service. Processors _MAY_ define short form notations as an authoring convenience (e.g., "scxml" as equivalent to http://www.w3.org/TR/scxml/).

A conformant SCXML document _MAY_ specify either the 'id' or 'idlocation' attribute, but _MUST NOT_ specify both. If the 'idlocation' attribute is present, the SCXML Processor _MUST_ generate an id automatically when the <invoke> element is evaluated and store it in the location specified by 'idlocation'. (In the rest of this document, we will refer to this identifier as the "invokeid", regardless of whether it is specified by the author or generated by the platform). The automatically generated identifier _MUST_ have the form _stateid.platformid_, where _stateid_ is the id of the state containing this element and _platformid_ is automatically generated. _platformid_ _MUST_ be unique within the current session.

When the <invoke> element is executed, if the evaluation of its arguments produces an error, the SCXML Processor _MUST_ terminate the processing of the element without further action. Otherwise the Processor _MUST_ start a new logical instance of the external service specified in 'type' or 'typeexpr', passing it the URL specified by 'src' or the data specified by <content>, "namelist" or <param>. (Note that the invoked service may ignore some or all of the data passed to it. See [_6.4.3 Implementation of <invoke>_](https://www.w3.org/TR/scxml/#invokeimplementation) for a discussion of how the passed data is treated by an invoked SCXML service.) The service instance _MAY_ be local or remote. In addition to the explicit arguments, the Processor _MUST_ keep track of the unique invokeid and ensure that it is included in all events that the invoked service returns to the invoking session.

When the 'autoforward' attribute is set to true, the SCXML Processor _MUST_ send an exact copy of every external event it receives to the invoked process. All the fields specified in [_5.10.1 The Internal Structure of Events_](https://www.w3.org/TR/scxml/#InternalStructureofEvents) _MUST_ have the same values in the forwarded copy of the event. The SCXML Processor _MUST_ forward the event at the point at which it removes it from the external event queue of the invoking session for processing.

The external service _MAY_ return multiple events while it is processing. If there is a <finalize> handler in the instance of <invoke> that created the service that generated the event, the SCXML Processor _MUST_ execute the code in that <finalize> handler right before it removes the event from the event queue for processing. It _MUST NOT_ execute the <finalize> handler in any other instance of <invoke>. Once the external service has finished processing it _MUST_ return a special event 'done.invoke._id_' to the external event queue of the invoking process, where _id_ is the invokeid for the corresponding <invoke> element. The external service _MUST NOT_ generate any other events after this done event. If the invoking session takes a transition out of the state containing the <invoke> before it receives the 'done.invoke._id_' event, the SCXML Processor _MUST_ automatically cancel the invoked component and stop its processing. The cancel operation _MUST_ act as if it were the final <onexit> handler in the invoking state.

Invoked services of type http://www.w3.org/TR/scxml/, http://www.w3.org/TR/ccxml/, http://www.w3.org/TR/voicexml30/, or http://www.w3.org/TR/voicexml21/ _MUST_ interpret values specified by the <content> element or 'src' attribute as markup to be executed. Similarly, they _MUST_ interpret values specified by <param> element or 'namelist' attribute as values that are to be injected into their data models. For targets of other invoked service types, the interpretation of <param> and <content> elements and the 'src' and 'namelist' attributes is platform-specific. However, these services _MUST_ treat values specified by <param> and namelist identically. They _MUST_ also treat values specified by 'src' and <content> identically.

#### 6.4.3 Implementation of <invoke>

The implementation of <invoke>, including communication between parent and child processes, is platform-specific, but the following requirements hold in the case where the invoked process is itself an SCXML session:

- If the 'name' of a <param> element in the <invoke> matches the 'id' of a <data> element in the top-level data declarations of the invoked session, the SCXML Processor _MUST_ use the value of the <param> element as the initial value of the corresponding <data> element. (The top-level data declarations are those that are contained in the <datamodel> element that is a child of <scxml>.) (Note that this means that any value specified in the <data> element is ignored.) The behavior of 'namelist' is similar. If the value of a key in the namelist matches the 'id' of a <data> element in the top-level data model of the invoked session, the SCXML Processor _MUST_ use the value of the key as the initial value of the corresponding <data> element. If the names do not match, the Processor _MUST NOT_ add the value of the <param> element or namelist key/value pair to the invoked session's data model. However the Processor _MAY_ make the values available by some other platform-specific means.
- When the invoked state machine reaches a top-level final state, the Processor _MUST_ place the event done.invoke._id_ on the external event queue of the invoking machine, where _id_ is the invokeid for this invocation. Note that reaching a top level final state corresponds to normal termination of the machine and that it cannot generate or process any further events once it is in this state.
- As described above, if the invoking state machine exits the state containing the invocation before it receives the done.invoke._id_ event, it cancels the invoked session. The method for doing this is platform-specific. However, when it is cancelled, the invoked session _MUST_ exit at the end of the next microstep. The Processor _MUST_ execute the <onexit> handlers for all active states in the invoked session, but it _MUST NOT_ generate the done.invoke._id_ event. Once it cancels the invoked session, the Processor _MUST_ ignore any events it receives from that session. In particular it _MUST NOT_ not insert them into the external event queue of the invoking session.- The SCXML Processor _MUST_ support the use of SCXML Event/IO processor ([_C.1 SCXML Event I/O Processor_](https://www.w3.org/TR/scxml/#SCXMLEventProcessor)) to communicate between the invoking and the invoked sessions. The Processor _MAY_ support the use of other Event/IO processors to communicate between the invoking and the invoked sessions.

#### 6.4.4 Data Sharing

\[This section is informative.\]

The invoked external resource is logically separate from the state machine that invokes it and does not share data with it unless the author explicitly requests this with the <param> or <content> elements and/or the 'src' and 'namelist' attributes.

The invoked and invoking process can also communicate via events. In addition to automatic forwarding specified by the 'autoforward' attribute. SCXML scripts can also use the <send> tag to send messages to the child process on an ad-hoc basis. The 'type' attribute of <send> is set to the same value as was used in the original <invoke>, while the target has the special form #\__invokeid_, where _invokeid_ is the identifier corresponding to the original <invoke> tag. For example, in a document using ECMAScript as the data model, the following code would invoke a VoiceXML session:

```
  &lt;invoke type="http://www.w3.org/TR/voicexml21/" idlocation="myInvoke"/&gt;

```

In this case, the unique invoke identifier has been stored in the data model location MyInvoke. Since the target attribute is an expression which is evaluated, the following code will extract that identifier and send a message to the invoked VoiceXML session:

```

  &lt;send type="http://www.w3.org/TR/voicexml21/" targetexpr="'#_' + myInvoke"/&gt;

```

Finally, in the case where the invoked external service is an SCXML session, it can use <send> with the special target '\_parent' and type 'scxml' to send events, possibly containing data, to the invoking session.

### 6.5 <finalize>

\[This section is normative.\]

The <finalize> element enables an invoking session to update its data model with data contained in events returned by the invoked session. <finalize> contains executable content that is executed whenever the external service returns an event after the <invoke> has been executed. This content is applied before the system looks for transitions that match the event. Within the executable content, the system variable '\_event' can be used to refer to the data contained in the event which is being processed.In the case of parallel states, only the finalize code in the original invoking state is executed.

In a conformant SCXML document, the executable content inside <finalize> _MUST NOT_ raise events or invoke external actions. In particular, the <send> and <raise> elements _MUST NOT_ occur.

If one or more elements of executable content is specified, the SCXML Processor _MUST_ execute them each time an event is received from the child process that was created by the parent <invoke> element. The Processor _MUST_ execute them right before the event is pulled off the external event queue for processing. The Processor _MUST NOT_ execute them at any other time or in response to any other events.

If no executable content is specified, the SCXML Processor _MUST_ update the data model each time an event is received from the child process that was created by the parent <invoke> element. Specifically if the parent <invoke> element contains a 'namelist' attribute or one or more <param> children containing 'location' attributes, then for each item in the 'namelist' attribute and each such <param> element, the Processor _MUST_ update the corresponding location as if by <assign> with any return value that has a name that matches the 'namelist' item or the 'name' of the <param> element. Thus the effect of an <invoke> with an empty <finalize> element and either a 'namelist' attribute or a <param> element with a 'location' attribute is first to send the part of the data model specified by 'namelist' or 'location' to the invoked component and then to update that part of the data model with any returned values that have the same name. Note that the automatic update does not take place if the <finalize> element is absent as opposed to empty.

In the example below, a state machine using an ECMAScript data model invokes a clock object that returns the current time in a ping event with an XML payload that includes the currentSecond, currentMinute, currentHour (1-12), and an isAm flag. <finalize> maps this data into an ECMAScript date object that is used in the condition of a transition. Thus <finalize> normalizes the data before the conditions on transitions are evaluated.

```
&lt;scxml version="1.0" datamodel="ecmascript"&gt;
....
 &lt;state id=getTime&gt;
   &lt;transition event=ping cond=time.getHours() &gt; 17 || time.getHours() &lt; 9 target=storeClosed/&gt;
   &lt;transition event=ping target=takeOrder/&gt;
   &lt;datamodel&gt;
     &lt;data id=time expr=new Date()/&gt;
   &lt;/datamodel&gt;
   &lt;invoke id=timer type=x-clock src=clock.pl&gt;
     &lt;finalize&gt;
       &lt;script&gt;
         time.setSeconds(_event.data.currentSecond);
         time.setMinutes(_event.data.currentMinute);
         time.setHours(_event.data.currentHour + (_event.isAm ? 0 : 12) - 1);
       &lt;/script&gt;
     &lt;/finalize&gt;
   &lt;/invoke&gt;
 &lt;/state&gt;
....

```

## B Data Models

\[This section is normative.\]

The 'datamodel' attribute on <scxml> defines the data model that the document uses. The data model includes the underlying data structure plus languages for boolean expressions, location expressions, value expressions, and scripting. A conformant SCXML document _MAY_ specify the data model it uses. Conformant SCXML processors _MUST_ support the null data model, and _MAY_ support other data models, including the ECMAScript and XPath data models. The ECMAScript and XPath model definitions given here are normative in the sense that they define how implementations that support one of these languages _MUST_ behave. The intent is to ensure interoperability among all processors that support ECMAScript, and all those that support XPath, without requiring all implementations to support either of those data model languages.

The definition of a data model _MUST_:

- Specify the boolean expression language used as the value of the 'cond' attribute in <transition>, <if> and <elseif> This language _MUST_ not have side effects and _MUST_ include the predicate 'In', which takes a single argument, the id of a state in the enclosing state machine, and returns 'true' if the state machine is in that state.
- Specify the location expression language that is used as the value of the 'location' attribute of the <assign> tag.
- Specify the value expression language that is used as the value of the 'expr' attribute of the <data> and <assign> elements.
- Specify the scripting language used inside the <script> element

### B.2 The ECMAScript Data Model

The value 'ecmascript' for the 'datamodel' attribute results in an ECMAScript data model. Implementations that support this value _MUST_ support the third edition of ECMAScript [\[ECMASCRIPT-262\]](https://www.w3.org/TR/scxml/#ECMAScript262). Implementations _MAY_ support JSON [\[RFC 4627\]](https://www.w3.org/TR/scxml/#JSON) or ECMAScript for XML (E4X) [\[E4X\]](https://www.w3.org/TR/scxml/#E4X).

#### B.2.8 System Variables

The SCXML Processor _MUST_ define an ECMAScript read-only variable for each system variable defined in [_5.10 System Variables_](https://www.w3.org/TR/scxml/#SystemVariables). The `_sessionid` and `_name` system variables are defined as variables with ECMAScript String values. The `_event` system variable is defined as an object with properties for each of the fields defined in [_5.10.1 The Internal Structure of Events_](https://www.w3.org/TR/scxml/#InternalStructureofEvents): `name`,`type`, `sendid`, `origin`, `origintype`, and `invokeid` are String values, while `data` can be of any type. In cases where this specification does not specify a value for one of these fields or states that the field is empty or has no value, the Processor _MUST_ set the value to ECMAScript undefined. As the value of the \_ioprocessors system variable the Processor _MUST_ create an object with a named property for each Event I/O processor that it supports, where the name of the property is the same as that of the I/O processor and the value of the property is an object that represents the I/O processor. For the SCXML and BasicHTTP Event I/O processors, the Processor _MUST_ create a "location" property under that object, assigning the access URI as its String value. For example, in systems that support the BasicHTTP Event I/O Processor, the access URI of the BasicHTTP Event I/O processor can be accessed as \_ioprocessors\['http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'\].location.

##### B.2.8.1 \_event.data

\_event.data is populated with content provided by an external event or by <param> or <content>. In some circumstances, the entity that generated the event may have indicated how the data is to be interpreted. In such cases, the Processor _SHOULD_ try to format the data according to those indications. Otherwise, if the SCXML Processsor can interpret the content as key-value pairs, then for each unique key, the Processor _MUST_ create a property of \_event.data whose name is the name of the key-value pair and whose value is the value of the key-value pair. In the case of duplicate keys, the behavior is platform-specific. (Note that content specified by <param> or delivered as POST parameters via the BasicHTTP Event I/O Processor consists unambiguously of key-value pairs.) Otherwise (i.e., if the content does not consist of key-value pairs), if the Processor supports JSON and it can interpret the content as JSON, it _MUST_ create the corresponding ECMAScript object(s) as the value of \_event.data. Otherwise, if the Processor can interpret the content as a valid XML document, it _MUST_ create the corresponding DOM structure and assign it as the value \_event.data. Otherwise, the Processor _MUST_ treat the content as a space-normalized string literal and assign it as the value of \_event.data.

Suppose as part of executing a state machine named "myName" with a platform-assigned sessionid "12345", we are processing an event with the name "foo.bar" and the following object payload:

Then the underlying ECMAScript data model would have the following form:

As an example, here is a sample transition that accesses the `_event` variable in that data model.

## C Event I/O Processors

\[This section is normative.\]

### C.1 SCXML Event I/O Processor

The SCXML Event I/O Processor is intended to transport messages between SCXML sessions. This specification defines the mapping between the parameters in the sending session and the event that is raised in the receiving session, but the transport mechanism is platform-specific.

The sending and receiving SCXML Processors _MUST_ maintain the following mappings:

- The 'name' field of the event raised in the receiving session _MUST_ match the value of the 'event' attribute of the <send> element in the sending session.
- The 'origin' field of the event raised in the receiving session _MUST_ match the value of the 'location' field inside the entry for the SCXML Event I/O Processor in the \_ioprocessors system variable in the sending session.
- The 'sendid' field of the event raised in the receiving session _MUST_ match the sendid in the sending session, if the author of the sending session specifies either the 'id' or 'idlocation' attribute. If the author does not specify either the 'id' or 'idlocation' attribute, the 'sendid' field _MUST_ be left empty.
- The 'origintype' field of the event raised in the receiving session _MUST_ have the value "scxml".2. The 'data' field of the event raised in the receiving session _MUST_ contain a copy of the data specified in the 'namelist' attribute or in <param> or <content> elements in the sending session. The nature of the copy operation depends on the data model in question. However, the Processor _MUST_ ensure that changes to the transmitted data in the receiving session do not affect the data in the sending session and vice-versa. The format of the 'data' field will depend on the data model of the receiving session. See [_B Data Models_](https://www.w3.org/TR/scxml/#profiles) for details. If the data models in the sending and receiving sessions are different, the mapping between them is platform-specific.

When using the SCXML Event I/O Processor, SCXML Processors _MUST_ support the following special targets for <send>:

- #\_internal. If the target is the special term '#\_internal', the Processor _MUST_ add the event to the internal event queue of the sending session.
- #\_scxml\__sessionid_. If the target is the special term '#\_scxml\__sessionid_', where _sessionid_ is the id of an SCXML session that is accessible to the Processor, the Processor _MUST_ add the event to the external queue of that session. The set of SCXML sessions that are accessible to a given SCXML Processor is platform-dependent.
- #\_parent. If the target is the special term '#\_parent', the Processor _MUST_ add the event to the external event queue of the SCXML session that invoked the sending session, if there is one. See [_6.4 <invoke>_](https://www.w3.org/TR/scxml/#invoke) for details.
- #\__invokeid_. If the target is the special term '#\__invokeid_', where _invokeid_ is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor _MUST_ add the event to the external queue of that session. See [_6.4 <invoke>_](https://www.w3.org/TR/scxml/#invoke) for details.

If neither the 'target' nor the 'targetexpr' attribute is specified, the SCXML Processor _MUST_ add the event to the external event queue of the sending session.

If the sending SCXML session specifies a session that does not exist or is inaccessible, the SCXML Processor _MUST_ place the error error.communication on the internal event queue of the sending session. If the receiving Processor cannot handle the data format contained in the message, the receiving Processor _MUST_ place the error error.communication in internal queue of the session for which the message was intended and _MUST_ ignore the message. The Processor _SHOULD_ also notify the sending processor of the error. If no errors occur, the receiving Processor _MUST_ convert the message into an SCXML event, using the mapping defined above, and insert the event into the appropriate queue, as defined in [_6.2.4 The Target of Send_](https://www.w3.org/TR/scxml/#SendTargets)

### C.2 Basic HTTP Event I/O Processor

The Basic HTTP Event I/O Processor is intended as a minimal interoperable mechanism for sending and receiving events to and from external components and SCXML 1.0 implementations. Support for the Basic HTTP Event I/O Processor is optional.

#### C.2.1 Receiving Events

An SCXML Processor that supports the Basic HTTP Event I/O Processor _MUST_ accept messages at the access URI as HTTP POST requests (see [\[RFC 2616\]](https://www.w3.org/TR/scxml/#HTTP)). The SCXML Processor _MUST_ validate the message it receives and then _MUST_ build the appropriate SCXML event and _MUST_ add it to the external event queue.

If a single instance of the parameter '\_scxmleventname' is present, the SCXML Processor _MUST_ use its value as the name of the SCXML event that it raises. If multiple instances of the parameter are present, the behavior is platform-specific. If the parameter '\_scxmleventname' is not present, the SCXML Processor _MUST_ use the name of the HTTP method that was used to deliver the message as the name of the event that it raises. The processor _MUST_ use any message content other than '\_scxmleventname' to populate \_event.data. See [_B Data Models_](https://www.w3.org/TR/scxml/#profiles) for details.

After it adds the received message to the appropriate event queue, the SCXML Processor _MUST_ then indicate the result to the external component via a success response code 2XX. Note that this response is sent before the event is removed from the queue and processed. In the cases where the message cannot be formed into an SCXML event, the Processor _MUST_ return an HTTP error code as defined in [\[RFC 2616\]](https://www.w3.org/TR/scxml/#HTTP).

#### C.2.2 Sending Events

An SCXML implementation can send events with the Basic HTTP Event I/O Processor using the <send> element (see [_6.2 <send>_](https://www.w3.org/TR/scxml/#send)) with the type attribute set to "http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor" and the target attribute set to the access URI of the target. If neither the 'target' nor the 'targetexpr' attribute is specified, the SCXML Processor _MUST_ add the event error.communication to the internal event queue of the sending session.

The SCXML Processor _MUST_ attempt to deliver the message using HTTP method "POST" and with parameter values encoded by default in an application/x-www-form-urlencoded body (POST method). An SCXML Processor _MAY_ support other encodings, and allow them to be specified in a platform-specific way.

If the 'event' parameter of <send> is defined, the SCXML Processor _MUST_ use its value as the value of the HTTP POST parameter \_scxmleventname. If the namelist attribute is defined, the SCXML Processor _MUST_ map its variable names and values to HTTP POST parameters. If one or more <param> children are present, the SCXML Processor _MUST_ map their names (i.e. name attributes) and values to HTTP POST parameters. If a <content> child is present, the SCXML Processor _MUST_ use its value as the body of the message.

## D Algorithm for SCXML Interpretation

\[This section is informative.\]

This section contains an illustrative algorithm for the interpretation of an SCXML document. It is intended as a guide for implementers only. Implementations are free to implement SCXML interpreters in any way they choose.

## Informal Semantics

The following definitions and highlevel principles and constraint are intended to provide a background to the algorithm, and to serve as a guide for the proper understanding of it.

### Preliminary definitions

state

An element of type <state>, <parallel>, or <final>.

pseudo state

An element of type <initial> or <history>.

transition target

A state, or an element of type <history>.

atomic state

A state of type <state> with no child states, or a state of type <final>.

compound state

A state of type <state> with at least one child state.

configuration

The maximal consistent set of states (including parallel and final states) that the machine is currently in. We note that if a state s is in the configuration c, it is always the case that the parent of s (if any) is also in c. Note, however, that <scxml> is not a(n explicit) member of the configuration.

source state

The source state of a transition is the state which contains the transition.

target state

A target state of a transition is a state that the transition is entering. Note that a transition can have zero or more target states.

targetless transition

A transition having zero target states.

eventless transition

A transition lacking the 'event' attribute.

external event

An SCXML event appearing in the external event queue. Such events are either sent by external sources or generated with the <send> element.

internal event

An event appearing in the internal event queue. Such events are either raised automatically by the platform or generated with the <raise> or <send> elements.

microstep

A microstep involves the processing of a single transition (or, in the case of parallel states, a single set of transitions.) A microstep may change the current configuration, update the data model and/or generate new (internal and/or external) events. This, by causality, may in turn enable additional transitions which will be handled in the next microstep in the sequence, and so on.

macrostep

A macrostep consists of a sequence (a chain) of microsteps, at the end of which the state machine is in a stable state and ready to process an external event. Each external event causes an SCXML state machine to take exactly one macrostep. However, if the external event does not enable any transitions, no microstep will be taken, and the corresponding macrostep will be empty.

### Principles and Constraints

We state here some principles and constraints, on the level of semantics, that SCXML adheres to:

Encapsulation

An SCXML processor is a _pure event processor_. The only way to get data into an SCXML state machine is to send external events to it. The only way to get data out is to receive events from it.

Causality

There shall be a _causal justification_ of why events are (or are not) returned back to the environment, which can be traced back to the events provided by the system environment.

Determinism

An SCXML state machine which does not invoke any external event processor must always react with the same behavior (i.e. the same sequence of output events) to a given sequence of input events (unless, of course, the state machine is explicitly programmed to exhibit an non-deterministic behavior). In particular, the availability of the <parallel> element must not introduce any non-determinism of the kind often associated with concurrency. Note that observable determinism does not necessarily hold for state machines that invoke other event processors.

Completeness

An SCXML interpreter must always treat an SCXML document as _completely_ specifying the behavior of a state machine. In particular, SCXML is designed to use priorities (based on document order) to resolve situations which other state machine frameworks would allow to remain under-specified (and thus non-deterministic, although in a different sense from the above).

Run to completion

SCXML adheres to a run to completion semantics in the sense that an external event can only be processed when the processing of the previous external event has completed, i.e. when all microsteps (involving all triggered transitions) have been completely taken.

Termination

A microstep always terminates. A macrostep may not. A macrostep that does not terminate may be said to consist of an infinitely long sequence of microsteps. This is currently allowed.

## Algorithm

Note that the algorithm assumes a Lisp-like semantics in which the empty Set null is equivalent to boolean 'false' and all other entities are equivalent to 'true'.

### Datatypes

These are the abstract datatypes that are used in the algorithm.

```
datatype List
   <code>function</code> head()      // Returns the head of the list
   <code>function</code> tail()      // Returns the tail of the list (i.e., the rest of the list once the head is removed)
   <code>function</code> append(l)   // Returns the list appended with l
   <code>function</code> filter(f)   // Returns the list of elements that satisfy the predicate f
   <code>function</code> some(f)     // Returns true if some element in the list satisfies the predicate f.  Returns false for an empty list.
   <code>function</code> every(f)    // Returns true if every element in the list satisfies the predicate f.  Returns true for an empty list.
The notation [...] is used as a list constructor, so that '[t]' denotes a list whose only member is the object t.

datatype OrderedSet
   <code>procedure</code> add(e)              // Adds e to the set if it is not already a member
   <code>procedure</code> delete(e)           // Deletes e from the set
   <code>procedure</code> union(s)            // Adds all members of s that are not already members of the set (s must also be an OrderedSet)
   <code>function</code> isMember(e)          // Is e a member of set?
   <code>function</code> some(f)              // Returns true if some element in the set satisfies the predicate f.  Returns false for an empty set.
   <code>function</code> every(f)             // Returns true if every element in the set satisfies the predicate f. Returns true for an empty set.
   <code>function</code> hasIntersection(s)   // Returns true if this set and  set s have at least one member in common
   <code>function</code>  isEmpty()           // Is the set empty?
   <code>procedure</code> clear()             // Remove all elements from the set (make it empty)
   <code>function</code>  toList()            // Converts the set to a list that reflects the order in which elements were originally added
                                 // In the case of sets created by intersection, the order of the first set (the one on which the method was called) is used
                                 // In the case of sets created by union, the members of the first set (the one on which union was called) retain their original ordering
                                 // while any members belonging to the second set only are placed after, retaining their ordering in their original set.


datatype Queue
   <code>procedure</code> enqueue(e) // Puts e last in the queue
   <code>function</code> dequeue()   // Removes and returns first element in queue
   <code>function</code> isEmpty()   // Is the queue empty?

datatype BlockingQueue
   <code>procedure</code> enqueue(e) // Puts e last in the queue
   <code>function</code> dequeue()   // Removes and returns first element in queue, blocks if queue is empty

datatype HashTable // table[foo] returns the value associated with foo.  table[foo] = bar sets the value associated with foo to be bar.
```

### Global variables

The following variables are global from the point of view of the algorithm. Their values will be set in the procedure interpret().

```
global configuration
global statesToInvoke
global datamodel
global internalQueue
global externalQueue
global historyValue
global running
global binding

```

### Predicates

The following binary predicates are used for determining the order in which states are entered and exited.

```
<a id="AlgorithmforSCXMLInterpretation" name="AlgorithmforSCXMLInterpretation"><code></code></a><code><a id="entryOrder" name="entryOrder">entryOrder</a></code> // Ancestors precede descendants, with document order being used to break ties
    (Note:since ancestors precede descendants, this is equivalent to document order.)
<code><a id="exitOrder" name="exitOrder">exitOrder</a></code>  // Descendants precede ancestors, with reverse document order being used to break ties
    (Note: since descendants follow ancestors, this is equivalent to reverse document order.)
```

The following binary predicate is used to determine the order in which we examine transitions within a state.

```
<a id="documentOrder" name="documentOrder">documentOrder</a>
```

### Procedures and Functions

This section defines the procedures and functions that make up the core of the SCXML interpreter. N.B. in the code below, the keyword 'continue' has its traditional meaning in languages like C: break off the current iteration of the loop and proceed to the next iteration.

#### `procedure` interpret(scxml,id)

The purpose of this procedure is to initialize the interpreter and to start processing.

In order to interpret an SCXML document, first (optionally) perform [\[xinclude\]](https://www.w3.org/TR/scxml/#xinclude) processing and (optionally) validate the document, throwing an exception if validation fails. Then convert initial attributes to <initial> container children with transitions to the state specified by the attribute. (This step is done purely to simplify the statement of the algorithm and has no effect on the system's behavior. Such transitions will not contain any executable content). Initialize the global data structures, including the data model. If binding is set to 'early', initialize the data model. Then execute the global <script> element, if any. Finally call enterStates on the initial configuration, set the global running variable to true and start the interpreter's event loop.

```
procedure interpret(doc):
    if not valid(doc): failWithError()
    expandScxmlSource(doc)
    configuration = new OrderedSet()
    statesToInvoke = new OrderedSet()
    internalQueue = new Queue()
    externalQueue = new BlockingQueue()
    historyValue = new HashTable()
    datamodel = new Datamodel(doc)
    if doc.binding == "early":
        initializeDatamodel(datamodel, doc)
    running = true
    executeGlobalScriptElement(doc)
    enterStates([doc.initial.transition])
    mainEventLoop()
```

#### `procedure` mainEventLoop()

This loop runs until we enter a top-level final state or an external entity cancels processing. In either case 'running' will be set to false (see EnterStates, below, for termination by entering a top-level final state.)

At the top of the loop, we have either just entered the state machine, or we have just processed an external event. Each iteration through the loop consists of four main steps: 1)Complete the macrostep by repeatedly taking any internally enabled transitions, namely those that don't require an event or that are triggered by an internal event. After each such transition/microstep, check to see if we have reached a final state. 2) When there are no more internally enabled transitions available, the macrostep is done. Execute any <invoke> tags for states that we entered on the last iteration through the loop 3) If any internal events have been generated by the invokes, repeat step 1 to handle any errors raised by the <invoke> elements. 4) When the internal event queue is empty, wait for an external event and then execute any transitions that it triggers. However special preliminary processing is applied to the event if the state has executed any <invoke> elements. First, if this event was generated by an invoked process, apply <finalize> processing to it. Secondly, if any <invoke> elements have autoforwarding set, forward the event to them. These steps apply before the transitions are taken.

This event loop thus enforces run-to-completion semantics, in which the system process an external event and then takes all the 'follow-up' transitions that the processing has enabled before looking for another external event. For example, suppose that the _external_ event queue contains events ext1 and ext2 and the machine is in state s1. If processing ext1 takes the machine to s2 and generates _internal_ event int1, and s2 contains a transition t triggered by int1, the system is guaranteed to take t, no matter what transitions s2 or other states have that would be triggered by ext2. Note that this is true even though ext2 was already in the external event queue when int1 was generated. In effect, the algorithm treats the processing of int1 as finishing up the processing of ext1.

```
procedure mainEventLoop():
    while running:
        enabledTransitions = null
        macrostepDone = false
        # Here we handle eventless transitions and transitions
        # triggered by internal events until macrostep is complete
        while running and not macrostepDone:
            enabledTransitions = selectEventlessTransitions()
            if enabledTransitions.isEmpty():
                if internalQueue.isEmpty():
                    macrostepDone = true
                else:
                    internalEvent = internalQueue.dequeue()
                    datamodel["_event"] = internalEvent
                    enabledTransitions = selectTransitions(internalEvent)
            if not enabledTransitions.isEmpty():
                microstep(enabledTransitions.toList())
        # either we're in a final state, and we break out of the loop
        if not running:
            break
        # or we've completed a macrostep, so we start a new macrostep by waiting for an external event
        # Here we invoke whatever needs to be invoked. The implementation of 'invoke' is platform-specific
        for state in statesToInvoke.sort(entryOrder):
            for inv in state.invoke.sort(documentOrder):
                invoke(inv)
        statesToInvoke.clear()
        # Invoking may have raised internal error events and we iterate to handle them
        if not internalQueue.isEmpty():
            continue
        # A blocking wait for an external event.  Alternatively, if we have been invoked
        # our parent session also might cancel us.  The mechanism for this is platform specific,
        # but here we assume its a special event we receive
        externalEvent = externalQueue.dequeue()
        if isCancelEvent(externalEvent):
            running = false
            continue
        datamodel["_event"] = externalEvent
        for state in configuration:
            for inv in state.invoke:
                if inv.invokeid == externalEvent.invokeid:
                    applyFinalize(inv, externalEvent)
                if inv.autoforward:
                    send(inv.id, externalEvent)
        enabledTransitions = selectTransitions(externalEvent)
        if not enabledTransitions.isEmpty():
            microstep(enabledTransitions.toList())
    # End of outer while running loop.  If we get here, we have reached a top-level final state or have been cancelled
    exitInterpreter()
```

#### `procedure` exitInterpreter()

The purpose of this procedure is to exit the current SCXML process by exiting all active states. If the machine is in a top-level final state, a Done event is generated. (Note that in this case, the final state will be the only active state.) The implementation of returnDoneEvent is platform-dependent, but if this session is the result of an <invoke> in another SCXML session, returnDoneEvent will cause the event done.invoke.<id> to be placed in the external event queue of that session, where <id> is the id generated in that session when the <invoke> was executed.

```
procedure exitInterpreter():
    statesToExit = configuration.toList().sort(exitOrder)
    for s in statesToExit:
        for content in s.onexit.sort(documentOrder):
            executeContent(content)
        for inv in s.invoke:
            cancelInvoke(inv)
        configuration.delete(s)
        if isFinalState(s) and isScxmlElement(s.parent):
            returnDoneEvent(s.donedata)
```

#### `function` selectEventlessTransitions()

This function selects all transitions that are enabled in the current configuration that do not require an event trigger. First find a transition with no 'event' attribute whose condition evaluates to `true`. If multiple matching transitions are present, take the first in document order. If none are present, search in the state's ancestors in ancestry order until one is found. As soon as such a transition is found, add it to enabledTransitions, and proceed to the next atomic state in the configuration. If no such transition is found in the state or its ancestors, proceed to the next state in the configuration. When all atomic states have been visited and transitions selected, filter the set of enabled transitions, removing any that are preempted by other transitions, then return the resulting set.

```
function selectEventlessTransitions():
    enabledTransitions = new OrderedSet()
    atomicStates = configuration.toList().filter(isAtomicState).sort(documentOrder)
    for state in atomicStates:
        loop: for s in [state].append(getProperAncestors(state, null)):
            for t in s.transition.sort(documentOrder):
                if not t.event and conditionMatch(t):
                    enabledTransitions.add(t)
                    break loop
    enabledTransitions = removeConflictingTransitions(enabledTransitions)
    return enabledTransitions
```

#### `function` selectTransitions(event)

The purpose of the selectTransitions()procedure is to collect the transitions that are enabled by this event in the current configuration.

Create an empty set of `enabledTransitions`. For each atomic state , find a transition whose 'event' attribute matches `event` and whose condition evaluates to `true`. If multiple matching transitions are present, take the first in document order. If none are present, search in the state's ancestors in ancestry order until one is found. As soon as such a transition is found, add it to enabledTransitions, and proceed to the next atomic state in the configuration. If no such transition is found in the state or its ancestors, proceed to the next state in the configuration. When all atomic states have been visited and transitions selected, filter out any preempted transitions and return the resulting set.

```
function selectTransitions(event):
    enabledTransitions = new OrderedSet()
    atomicStates = configuration.toList().filter(isAtomicState).sort(documentOrder)
    for state in atomicStates:
        loop: for s in [state].append(getProperAncestors(state, null)):
            for t in s.transition.sort(documentOrder):
                if t.event and nameMatch(t.event, event.name) and conditionMatch(t):
                    enabledTransitions.add(t)
                    break loop
    enabledTransitions = removeConflictingTransitions(enabledTransitions)
    return enabledTransitions
```

#### `function` removeConflictingTransitions(enabledTransitions)

enabledTransitions will contain multiple transitions only if a parallel state is active. In that case, we may have one transition selected for each of its children. These transitions may conflict with each other in the sense that they have incompatible target states. Loosely speaking, transitions are compatible when each one is contained within a single <state> child of the <parallel> element. Transitions that aren't contained within a single child force the state machine to leave the <parallel> ancestor (even if they reenter it later). Such transitions conflict with each other, and with transitions that remain within a single <state> child, in that they may have targets that cannot be simultaneously active. The test that transitions have non-intersecting exit sets captures this requirement. (If the intersection is null, the source and targets of the two transitions are contained in separate <state> descendants of <parallel>. If intersection is non-null, then at least one of the transitions is exiting the <parallel>). When such a conflict occurs, then if the source state of one of the transitions is a descendant of the source state of the other, we select the transition in the descendant. Otherwise we prefer the transition that was selected by the earlier state in document order and discard the other transition. Note that targetless transitions have empty exit sets and thus do not conflict with any other transitions.

We start with a list of enabledTransitions and produce a conflict-free list of filteredTransitions. For each t1 in enabledTransitions, we test it against all t2 that are already selected in filteredTransitions. If there is a conflict, then if t1's source state is a descendant of t2's source state, we prefer t1 and say that it preempts t2 (so we we make a note to remove t2 from filteredTransitions). Otherwise, we prefer t2 since it was selected in an earlier state in document order, so we say that it preempts t1. (There's no need to do anything in this case since t2 is already in filteredTransitions. Furthermore, once one transition preempts t1, there is no need to test t1 against any other transitions.) Finally, if t1 isn't preempted by any transition in filteredTransitions, remove any transitions that it preempts and add it to that list.

```
function removeConflictingTransitions(enabledTransitions):
    filteredTransitions = new OrderedSet()
    //toList sorts the transitions in the order of the states that selected them
    for t1 in enabledTransitions.toList():
        t1Preempted = false
        transitionsToRemove = new OrderedSet()
        for t2 in filteredTransitions.toList():
            if computeExitSet([t1]).hasIntersection(computeExitSet([t2])):
                if isDescendant(t1.source, t2.source):
                    transitionsToRemove.add(t2)
                else:
                    t1Preempted = true
                    break
        if not t1Preempted:
            for t3 in transitionsToRemove.toList():
                filteredTransitions.delete(t3)
            filteredTransitions.add(t1)

    return filteredTransitions
```

#### `procedure` microstep(enabledTransitions)

The purpose of the microstep `procedure` is to process a single set of transitions. These may have been enabled by an external event, an internal event, or by the presence or absence of certain values in the data model at the current point in time. The processing of the enabled transitions must be done in parallel ('lock step') in the sense that their source states must first be exited, then their actions must be executed, and finally their target states entered.

If a single atomic state is active, then enabledTransitions will contain only a single transition. If multiple states are active (i.e., we are in a parallel region), then there may be multiple transitions, one per active atomic state (though some states may not select a transition.) In this case, the transitions are taken in the document order of the atomic states that selected them.

```
procedure microstep(enabledTransitions):
    exitStates(enabledTransitions)
    executeTransitionContent(enabledTransitions)
    enterStates(enabledTransitions)
```

#### `procedure` exitStates(enabledTransitions)

Compute the set of states to exit. Then remove all the states on statesToExit from the set of states that will have invoke processing done at the start of the next macrostep. (Suppose macrostep M1 consists of microsteps m11 and m12. We may enter state s in m11 and exit it in m12. We will add s to statesToInvoke in m11, and must remove it in m12. In the subsequent macrostep M2, we will apply invoke processing to all states that were entered, and not exited, in M1.) Then convert statesToExit to a list and sort it in exitOrder.

For each state s in the list, if s has a deep history state h, set the history value of h to be the list of all atomic descendants of s that are members in the current configuration, else set its value to be the list of all immediate children of s that are members of the current configuration. Again for each state s in the list, first execute any onexit handlers, then cancel any ongoing invocations, and finally remove s from the current configuration.

```
procedure exitStates(enabledTransitions):
    statesToExit = computeExitSet(enabledTransitions)
    for s in statesToExit:
        statesToInvoke.delete(s)
    statesToExit = statesToExit.toList().sort(exitOrder)
    for s in statesToExit:
        for h in s.history:
            if h.type == "deep":
                f = lambda s0: isAtomicState(s0) and isDescendant(s0,s)
            else:
                f = lambda s0: s0.parent == s
            historyValue[h.id] = configuration.toList().filter(f)
    for s in statesToExit:
        for content in s.onexit.sort(documentOrder):
            executeContent(content)
        for inv in s.invoke:
            cancelInvoke(inv)
        configuration.delete(s)
```

#### `procedure` computeExitSet(enabledTransitions)

For each transition t in enabledTransitions, if t is targetless then do nothing, else compute the transition's domain. (This will be the source state in the case of internal transitions) or the least common compound ancestor state of the source state and target states of t (in the case of external transitions. Add to the statesToExit set all states in the configuration that are descendants of the domain.

```
function computeExitSet(transitions)
    statesToExit = new OrderedSet
    for t in transitions:
        if t.target:
            domain = getTransitionDomain(t)
            for s in configuration:
                if isDescendant(s,domain):
                    statesToExit.add(s)
    return statesToExit

```

#### `procedure` executeTransitionContent(enabledTransitions)

For each transition in the list of `enabledTransitions`, execute its executable content.

```
procedure executeTransitionContent(enabledTransitions):
    for t in enabledTransitions:
        executeContent(t)
```

#### `procedure` enterStates(enabledTransitions)

First, compute the list of all the states that will be entered as a result of taking the transitions in enabledTransitions. Add them to statesToInvoke so that invoke processing can be done at the start of the next macrostep. Convert statesToEnter to a list and sort it in entryOrder. For each state s in the list, first add s to the current configuration. Then if we are using late binding, and this is the first time we have entered s, initialize its data model. Then execute any onentry handlers. If s's initial state is being entered by default, execute any executable content in the initial transition. If a history state in s was the target of a transition, and s has not been entered before, execute the content inside the history state's default transition. Finally, if s is a final state, generate relevant Done events. If we have reached a top-level final state, set running to false as a signal to stop processing.

```
procedure enterStates(enabledTransitions):
    statesToEnter = new OrderedSet()
    statesForDefaultEntry = new OrderedSet()
    // initialize the temporary table for default content in history states
    defaultHistoryContent = new HashTable()
    computeEntrySet(enabledTransitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    for s in statesToEnter.toList().sort(entryOrder):
        configuration.add(s)
        statesToInvoke.add(s)
        if binding == "late" and s.isFirstEntry:
            initializeDataModel(datamodel.s,doc.s)
            s.isFirstEntry = false
        for content in s.onentry.sort(documentOrder):
            executeContent(content)
        if statesForDefaultEntry.isMember(s):
            executeContent(s.initial.transition)
        if defaultHistoryContent[s.id]:
            executeContent(defaultHistoryContent[s.id])
        if isFinalState(s):
            if isSCXMLElement(s.parent):
                running = false
            else:
                parent = s.parent
                grandparent = parent.parent
                internalQueue.enqueue(new Event("done.state." + parent.id, s.donedata))
                if isParallelState(grandparent):
                    if getChildStates(grandparent).every(isInFinalState):
                        internalQueue.enqueue(new Event("done.state." + grandparent.id))

```

#### `procedure` computeEntrySet(transitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent)

Compute the complete set of states that will be entered as a result of taking 'transitions'. This value will be returned in 'statesToEnter' (which is modified by this procedure). Also place in 'statesForDefaultEntry' the set of all states whose default initial states were entered. First gather up all the target states in 'transitions'. Then add them and, for all that are not atomic states, add all of their (default) descendants until we reach one or more atomic states. Then add any ancestors that will be entered within the domain of the transition. (Ancestors outside of the domain of the transition will not have been exited.)

```
procedure computeEntrySet(transitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    for t in transitions:
        for s in t.target:
            addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
        ancestor = getTransitionDomain(t)
        for s in getEffectiveTargetStates(t)):
            addAncestorStatesToEnter(s, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
```

#### `procedure` addDescendantStatesToEnter(state,statesToEnter,statesForDefaultEntry, defaultHistoryContent)

The purpose of this procedure is to add to statesToEnter 'state' and any of its descendants that the state machine will end up entering when it enters 'state'. (N.B. If 'state' is a history pseudo-state, we dereference it and add the history value instead.) Note that this procedure permanently modifies both statesToEnter and statesForDefaultEntry.

First, If state is a history state then add either the history values associated with state or state's default target to statesToEnter. Then (since the history value may not be an immediate descendant of 'state's parent) add any ancestors between the history value and state's parent. Else (if state is not a history state), add state to statesToEnter. Then if state is a compound state, add state to statesForDefaultEntry and recursively call addStatesToEnter on its default initial state(s). Then, since the default initial states may not be children of 'state', add any ancestors between the default initial states and 'state'. Otherwise, if state is a parallel state, recursively call addStatesToEnter on any of its child states that don't already have a descendant on statesToEnter.

```
procedure addDescendantStatesToEnter(state,statesToEnter,statesForDefaultEntry, defaultHistoryContent):
    if isHistoryState(state):
        if historyValue[state.id]:
            for s in historyValue[state.id]:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in historyValue[state.id]:
                addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
        else:
            defaultHistoryContent[state.parent.id] = state.transition.content
            for s in state.transition.target:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in state.transition.target:
                addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    else:
        statesToEnter.add(state)
        if isCompoundState(state):
            statesForDefaultEntry.add(state)
            for s in state.initial.transition.target:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in state.initial.transition.target:
                addAncestorStatesToEnter(s, state, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
        else:
            if isParallelState(state):
                for child in getChildStates(state):
                    if not statesToEnter.some(lambda s: isDescendant(s,child)):
                        addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent)

```

#### `procedure` addAncestorStatesToEnter(state, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)

Add to statesToEnter any ancestors of 'state' up to, but not including, 'ancestor' that must be entered in order to enter 'state'. If any of these ancestor states is a parallel state, we must fill in its descendants as well.

```
procedure addAncestorStatesToEnter(state, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    for anc in getProperAncestors(state,ancestor):
        statesToEnter.add(anc)
        if isParallelState(anc):
            for child in getChildStates(anc):
                if not statesToEnter.some(lambda s: isDescendant(s,child)):
                    addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
```

#### `procedure` isInFinalState(s)

Return true if s is a compound <state> and one of its children is an active <final> state (i.e. is a member of the current configuration), or if s is a <parallel> state and isInFinalState is true of all its children.

```
function isInFinalState(s):
    if isCompoundState(s):
        return getChildStates(s).some(lambda s: isFinalState(s) and configuration.isMember(s))
    elif isParallelState(s):
        return getChildStates(s).every(isInFinalState)
    else:
        return false
```

#### `function` getTransitionDomain(transition)

Return the compound state such that 1) all states that are exited or entered as a result of taking 'transition' are descendants of it 2) no descendant of it has this property.

```
function getTransitionDomain(t)
    tstates = getEffectiveTargetStates(t)
    if not tstates:
        return null
    elif t.type == "internal" and isCompoundState(t.source) and tstates.every(lambda s: isDescendant(s,t.source)):
        return t.source
    else:
        return findLCCA([t.source].append(tstates))

```

#### `function` findLCCA(stateList)

The Least Common Compound Ancestor is the <state> or <scxml> element s such that s is a proper ancestor of all states on stateList and no descendant of s has this property. Note that there is guaranteed to be such an element since the <scxml> wrapper element is a common ancestor of all states. Note also that since we are speaking of proper ancestor (parent or parent of a parent, etc.) the LCCA is never a member of stateList.

```
function findLCCA(stateList):
    for anc in getProperAncestors(stateList.head(),null).filter(isCompoundStateOrScxmlElement):
        if stateList.tail().every(lambda s: isDescendant(s,anc)):
            return anc

```

#### `function` getEffectiveTargetStates(transition)

Returns the states that will be the target when 'transition' is taken, dereferencing any history states.

```
function getEffectiveTargetStates(transition)
    targets = new OrderedSet()
    for s in transition.target
        if isHistoryState(s):
            if historyValue[s.id]:
                targets.union(historyValue[s.id])
            else:
                targets.union(getEffectiveTargetStates(s.transition))
        else:
            targets.add(s)
    return targets

```

#### `function` getProperAncestors(state1, state2)

If state2 is null, returns the set of all ancestors of state1 in ancestry order (state1's parent followed by the parent's parent, etc. up to an including the <scxml> element). If state2 is non-null, returns in ancestry order the set of all ancestors of state1, up to but not including state2. (A "proper ancestor" of a state is its parent, or the parent's parent, or the parent's parent's parent, etc.))If state2 is state1's parent, or equal to state1, or a descendant of state1, this returns the empty set.

#### `function` isDescendant(state1, state2)

Returns 'true' if state1 is a descendant of state2 (a child, or a child of a child, or a child of a child of a child, etc.) Otherwise returns 'false'.

#### `function` getChildStates(state1)

Returns a list containing all <state>, <final>, and <parallel> children of state1.

## F Related Work

\[This section is informative.\]

A number of other XML-based state machine notations have been developed, but none serves the same purpose as SCXML. XMI [\[UML XMI\]](https://www.w3.org/TR/scxml/#XMI) is a notation developed for representing UML diagrams, including Harel statecharts. However it is intended as a machine interchange format and is not readily authorable by humans. ebXML [\[ebXML\]](https://www.w3.org/TR/scxml/#ebXML) is a language for business process specification intended to support B2B e-commerce applications. It contains a state machine language that is in some ways similar to the one presented here, but its syntax and semantics are closely tied to its intended use in e-commerce. It is therefore not suitable as a general-purpose state machine language. XTND [\[XTND\]](https://www.w3.org/TR/scxml/#XTND), also called XML Transition Network Definition, is a notation for simple finite state machines but lacks Harel's notions of hierarchical and parallel states and are thus not suitable for a general-purpose state machine that is semantically equivalent to Harel state charts.

## H MIME Type

\[This section is normative.\]

This appendix registers a new MIME media type, "`application/scxml+xml`".

The "`application/scxml+xml`" media type is being submitted to the IESG for review, approval, and registration with IANA.

### H.1 Registration of MIME media type application/scxml+xml

MIME media type name:

`application`

MIME subtype name:

`scxml+xml`

Required parameters:

None

Optional parameters:

`charset`

This parameter has identical semantics to the `charset` parameter of the `application/xml` media type as specified in [\[RFC 3023\]](https://www.w3.org/TR/scxml/#RFC3023) or its successor.

Encoding considerations:

By virtue of SCXML content being XML, it has the same considerations when sent as "application/scxml+xml"as does XML. See [\[RFC 3023\]](https://www.w3.org/TR/scxml/#RFC3023) (or its successor), section 3.2.

Security considerations:

SCXML elements may include arbitrary URIs. Therefore, the security issues of [\[RFC 3986\]](https://www.w3.org/TR/scxml/#RFC3986) section 7 should be considered. In addition, because of the extensibility features for SCXML, it is possible that "`application/scxml+xml`" may describe content that has security implications beyond those described here. However, if the processor follows only the normative semantics of this specification, this content will be ignored. Only in the case where the processor recognizes and processes the additional content, or where further processing of that content is dispatched to other processors, would security issues potentially arise. And in that case, they would fall outside the domain of this registration document.

Interoperability considerations:

This specification describes processing semantics that dictate behavior that must be followed when dealing with, among other things, unrecognized elements.Because SCXML is extensible, conformant "`application/scxml+xml`" processors MAY expect that content received is well-formed XML, but processors SHOULD NOT assume that the content is valid SCXML or expect to recognize all of the elements and attributes in the document.

Published specification:

This media type registration is extracted from Appendix H of the [State Chart XML (SCXML): State Machine Notation for Control Abstraction](https://www.w3.org/TR/scxml/) specification.

Additional information:

Magic number(s):

There is no single initial octet sequence that is always present in SCXML documents.

File extension(s):

SCXML documents are most often identified with the extensions "`.scxml`".

Macintosh File Type Code(s):

TEXT

Person and email address to contact for further information:

Kazuyuki Ashimura, <[ashimura@w3.org](mailto:ashimura@w3.org)\>.

Intended usage:

COMMON

Restrictions on usage:

None

Author:

The SCXML specification is a work product of the World Wide Web Consortium's Voice Browser Working Group.

Change controller:

The W3C has change control over these specifications.
