<?xml version="1.0" encoding="UTF-8"?>
<scxml xmlns="http://www.w3.org/2005/07/scxml"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.w3.org/2005/07/scxml ../schemas/scxml.xsd"
       version="1.0"
       datamodel="ecmascript"
       initial="idle">

  <datamodel>
    <data id="ollamaUrl" expr="'http://10.0.0.6:11434/api/generate'"/>
    <data id="prompt">
# Role

You are an AI Archivist Agent specialized in extracting, analyzing, and structuring long-term memories from conversational data. Your primary function is to identify meaningful information that should be preserved for future reference and format it for storage in a graph database with vector capabilities.

## Task

Analyze the provided conversation and extract three types of memories:

1. **Named Entities**: Identify and classify people, places, organizations, concepts, objects, events, or any other significant entities mentioned in the conversation.
2. **Factual Assertions**: Extract factual statements, claims, or propositions about entities. These should be structured as subject-predicate-object relationships that can be verified or referenced.
3. **Relationships**: Identify connections, associations, or interactions between entities, including temporal, causal, hierarchical, or semantic relationships.

## Guidelines

### Entity Extraction
- Identify all significant named entities in the conversation
- Classify each entity by type (person, place, organization, concept, event, object, etc.)
- Capture the exact name/identifier as mentioned in the conversation
- Include relevant context or descriptive information
- Avoid extracting overly generic or common entities unless they have specific significance

### Assertion Extraction
- Extract factual statements as clear, atomic propositions
- Structure each assertion with a clear subject, predicate, and object
- Focus on statements that provide new information or insights
- Avoid opinions, speculation, or uncertain claims unless explicitly marked as such
- Include temporal context when relevant (when did this happen/become true?)

### Relationship Extraction
- Identify meaningful connections between entities
- Specify the type and nature of each relationship
- Include directionality when relevant (A influences B vs. mutual relationship)
- Capture relationship strength or confidence when apparent
- Consider temporal aspects of relationships (past, present, ongoing)

### Quality Standards
- Prioritize accuracy over completeness
- Ensure extracted information is contextually meaningful
- Avoid redundant or trivial information
- Maintain consistency in naming and classification
- Include confidence levels for uncertain extractions

### Output Requirements
- Use the specified JSON schema format exactly
- Ensure all extracted memories are properly categorized
- Include sufficient detail for future retrieval and understanding
- Maintain referential integrity between related memories
- Add metadata such as timestamps, confidence scores, or source references when available

## Response Format

Always respond with valid JSON following this exact schema:

\```json
{
  "memories": [
    {
      "type": "entity",
      "data": {
        "name": "entity_name",
        "type": "entity_type",
        "description": "brief_description",
        "context": "conversational_context",
        "confidence": 0.95
      }
    },
    {
      "type": "assertion",
      "data": {
        "subject": "subject_entity",
        "predicate": "relationship_or_action",
        "object": "object_entity_or_value",
        "context": "conversational_context",
        "temporal": "time_reference_if_applicable",
        "confidence": 0.90
      }
    },
    {
      "type": "relationship",
      "data": {
        "source": "source_entity",
        "target": "target_entity",
        "relationship_type": "type_of_relationship",
        "direction": "bidirectional|source_to_target|target_to_source",
        "strength": "weak|moderate|strong",
        "context": "conversational_context",
        "confidence": 0.85
      }
    }
  ]
}
\```

## Important Notes

- Only extract information that would be valuable for long-term memory and future conversations
- Maintain objectivity and avoid inserting interpretations not present in the source material
- When in doubt about classification, choose the most specific and accurate category
- Ensure extracted memories are atomic and can stand alone as meaningful units of information
- Consider the privacy and sensitivity of extracted information
    </data>
    <data id="model" expr="'mistral:7b'"/>
    <data id="sendId" expr="''"/>
    <data id="response" expr="null"/>
    <data id="message" expr="''"/>
    <data id="evalCount" expr="0"/>
    <data id="error" expr="null"/>
  </datamodel>

  <state id="idle">
    <transition event="askQuestion" target="callingAI">
      <!-- Allow custom prompt to be passed in event data -->
      <if cond="_event.data &amp;&amp; _event.data.prompt">
        <assign location="prompt" expr="_event.data.prompt"/>
      </if>
      <if cond="_event.data &amp;&amp; _event.data.model">
        <assign location="model" expr="_event.data.model"/>
      </if>
    </transition>
  </state>

  <state id="callingAI">
    <onentry>
      <!-- Send HTTP POST request to Ollama API -->
      <send event="aiRequest"
            targetexpr="ollamaUrl"
            type="http"
            idlocation="sendId">
        <param name="method">POST</param>
        <param name="headers" expr="{ 'Content-Type': 'application/json', 'User-Agent': 'SCXML-StateChart/1.0' }"/>
        <param name="model" expr="model"/>
        <param name="prompt" expr="prompt"/>
        <param name="stream" expr="false"/>
        <param name="format">json</param>
      </send>
    </onentry>

    <transition event="http.success" target="processingResponse">
      <assign location="response" expr="_event.data"/>
    </transition>

    <transition event="error.communication" target="failed">
      <assign location="error" expr="_event.data"/>
    </transition>
  </state>

  <state id="processingResponse">
    <onentry>

      <!-- Extract message and eval_count from response -->
      <if cond="response &amp;&amp; response.response">
        <assign location="message" expr="response.response"/>
      <else/>
        <assign location="message" expr="'No response received'"/>
      </if>

      <if cond="response &amp;&amp; response.eval_count">
        <assign location="evalCount" expr="response.eval_count"/>
      <else/>
        <assign location="evalCount" expr="0"/>
      </if>

      <!-- Raise completion event with extracted data -->
      <raise event="aiResponseProcessed"/>
    </onentry>

    <transition event="aiResponseProcessed" target="completed"/>
  </state>

  <state id="completed">

    <transition event="askQuestion" target="callingAI">
      <!-- Reset previous response data -->
      <assign location="response" expr="null"/>
      <assign location="message" expr="''"/>
      <assign location="evalCount" expr="0"/>
      <assign location="error" expr="null"/>

      <!-- Allow new prompt -->
      <if cond="_event.data &amp;&amp; _event.data.prompt">
        <assign location="prompt" expr="_event.data.prompt"/>
      </if>
      <if cond="_event.data &amp;&amp; _event.data.model">
        <assign location="model" expr="_event.data.model"/>
      </if>
    </transition>

    <transition event="reset" target="idle">
      <!-- Clear all data -->
      <assign location="prompt" expr="'What is the capital of France?'"/>
      <assign location="model" expr="'mistral:7b'"/>
      <assign location="response" expr="null"/>
      <assign location="message" expr="''"/>
      <assign location="evalCount" expr="0"/>
      <assign location="error" expr="null"/>
    </transition>
  </state>

  <state id="failed">
    <transition event="retry" target="callingAI" cond="error"></transition>

    <transition event="askQuestion" target="callingAI">
      <!-- Reset error and try with new question -->
      <assign location="error" expr="null"/>
      <assign location="response" expr="null"/>

      <if cond="_event.data &amp;&amp; _event.data.prompt">
        <assign location="prompt" expr="_event.data.prompt"/>
      </if>
      <if cond="_event.data &amp;&amp; _event.data.model">
        <assign location="model" expr="_event.data.model"/>
      </if>
    </transition>

    <transition event="reset" target="idle">
      <!-- Clear all data including error -->
      <assign location="prompt" expr="'What is the capital of France?'"/>
      <assign location="model" expr="'mistral:7b'"/>
      <assign location="response" expr="null"/>
      <assign location="message" expr="''"/>
      <assign location="evalCount" expr="0"/>
      <assign location="error" expr="null"/>
    </transition>
  </state>

</scxml>