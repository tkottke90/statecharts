# State Execution History

The State Execution History system provides comprehensive tracking and debugging capabilities for SCXML state machine execution. This system is separate from SCXML `<history>` elements and is designed for debugging, visualization, and monitoring purposes.

## Overview

The State Execution History system is a comprehensive debugging and monitoring solution that records every significant action your SCXML state machine performs during runtime. Think of it as a "black box recorder" for your state machine - it captures a detailed timeline of what happened, when it happened, and why it happened.

### What Problems Does It Solve?

**Debugging Complex State Machines**: When your state machine isn't behaving as expected, traditional debugging tools only show you the current state. History tracking shows you the entire execution path that led to the current state, making it much easier to identify where things went wrong.

**Performance Analysis**: Identify bottlenecks by seeing which state transitions take the longest, which events are processed most frequently, and where your state machine spends most of its time.

**Production Monitoring**: Track state machine behavior in production environments without impacting performance, allowing you to catch issues before they become critical problems.

**Testing and Validation**: Verify that your state machine follows expected execution paths during automated testing, and replay specific scenarios for debugging.

### What Information Does It Capture?

The system records detailed information about every aspect of state machine execution:

- **State Transitions**: Every time a state is entered or exited, including precise timestamps and duration measurements. This helps you understand the flow of execution and identify slow transitions.

- **Event Processing**: Records both internal events (generated by the state machine itself) and external events (sent from your application code). Each event includes its payload data and processing time.

- **Execution Steps**: SCXML execution happens in "macrosteps" (complete event processing cycles) and "microsteps" (individual transition processing). The history tracks both levels, giving you insight into the internal execution model.

- **Causality Tracking**: Maintains parent-child relationships between execution events, so you can see how one event triggered another. For example, entering a state might trigger an internal event, which causes another transition.

- **Error Tracking**: Automatically captures any errors that occur during state machine execution, including the full context of what was happening when the error occurred.

- **Performance Metrics**: Precise timing measurements for all operations, memory usage statistics, and execution frequency data to help optimize your state machine's performance.

### How It Works

The history system operates as a passive observer - it doesn't change how your state machine behaves, it just records what happens. It uses an event-driven architecture where each significant action in the state machine emits a history event that gets stored in a configurable buffer.

The system is designed to be production-ready with minimal performance overhead. You can configure it to track only the events you care about, limit memory usage with automatic cleanup, and export/import history data for offline analysis.

## Core Components

### HistoryEventType

This enum defines all the different types of events that the history system can track. Each event type captures a specific moment or action in your state machine's execution:

```typescript
enum HistoryEventType {
  STATE_ENTRY = 'state_entry',        // When a state becomes active
  STATE_EXIT = 'state_exit',          // When a state becomes inactive
  TRANSITION = 'transition',          // When a transition is taken between states
  EVENT_PROCESSED = 'event_processed', // When an SCXML event is handled
  MICROSTEP_START = 'microstep_start', // Beginning of a single transition processing
  MICROSTEP_END = 'microstep_end',     // End of a single transition processing
  MACROSTEP_START = 'macrostep_start', // Beginning of a complete event processing cycle
  MACROSTEP_END = 'macrostep_end',     // End of a complete event processing cycle
  ERROR = 'error',                     // When an error occurs during execution
}
```

**Understanding the Event Types:**

- **STATE_ENTRY/STATE_EXIT**: These are the most commonly used events for debugging. They tell you exactly when your state machine moves between states, which is crucial for understanding execution flow.

- **TRANSITION**: Captures the actual transition being taken, including source state, target state, and the triggering event. This is different from STATE_ENTRY/STATE_EXIT because a single transition might exit multiple states and enter multiple states.

- **EVENT_PROCESSED**: Records when your state machine processes an event (like `sendEvent('start')`). This helps you trace which events caused which state changes.

- **MICROSTEP_START/END**: SCXML processes transitions in small steps called "microsteps." Each microstep handles one transition. These events help you understand the internal execution order when multiple transitions could be taken.

- **MACROSTEP_START/END**: A "macrostep" is a complete cycle of processing one event, which might involve multiple microsteps. These events help you measure the total time to process an event and understand execution boundaries.

- **ERROR**: Automatically captured when something goes wrong, providing context about what the state machine was doing when the error occurred.

### HistoryEntry

This is the core data structure that represents a single recorded event in your state machine's execution. Think of it as a "snapshot" that captures everything important about what happened at a specific moment:

```typescript
interface HistoryEntry {
  id: HistoryId;                    // Unique identifier for this specific event
  timestamp: number;                // Precise time when this event occurred (milliseconds)
  type: HistoryEventType;          // What kind of event this was (entry, exit, transition, etc.)
  stateConfiguration: string[];     // Which states were active when this event happened
  internalState: InternalState;    // Complete state machine data at this moment
  event?: SCXMLEvent;              // The SCXML event that triggered this (if applicable)
  transition?: StateTransition;     // Details about the transition taken (if applicable)
  duration?: number;               // How long this operation took (milliseconds)
  error?: Error;                   // Any error that occurred (if applicable)
  metadata: Record<string, any>;   // Additional context and debugging information
  parentId?: HistoryId;            // Links to the event that caused this one
  childIds: HistoryId[];           // Links to events that this one caused
}
```

**Understanding Each Field:**

- **id**: A unique identifier (like "20241215-143052-001") that lets you reference this specific event. Useful for building causality chains and cross-referencing events.

- **timestamp**: Precise timing using `Date.now()` or `performance.now()`. This lets you build timelines, measure durations, and correlate events with external logs.

- **stateConfiguration**: An array of currently active state names (like `["idle", "connected", "authenticated"]`). This is crucial for understanding the state machine's context when the event occurred.

- **internalState**: The complete data model of your state machine at this moment, including all variables and their values. This is like a "memory dump" that shows exactly what data was available.

- **event**: If this history entry was triggered by processing an SCXML event (like when you call `sendEvent('start')`), this field contains the complete event object including its name and data payload.

- **transition**: For transition-related events, this contains detailed information about the source state, target state, which states were exited/entered, and what triggered the transition.

- **duration**: How long the operation took to complete. For example, entering a state might take 5ms if it has complex onentry actions, while a simple state exit might take 0.1ms.

- **parentId/childIds**: These create a tree structure showing causality. For example, processing an event (parent) might cause multiple state exits and entries (children), helping you trace the ripple effects of each action.

### StateExecutionHistory

This is the main class that manages all history tracking functionality. It extends Node.js's `EventEmitter`, which means it can emit events that your application can listen to for real-time monitoring:

```typescript
class StateExecutionHistory extends EventEmitter {
  // Core Methods - Adding and retrieving history entries
  addEntry(type: HistoryEventType, stateConfig: string[], state: InternalState, options?: Partial<HistoryEntry>): HistoryId
  getEntry(id: HistoryId): HistoryEntry | undefined
  getAllEntries(): HistoryEntry[]

  // Query Methods - Powerful searching and filtering
  query(options?: HistoryQueryOptions): HistoryQueryResult

  // Causality Tracking - Understanding cause-and-effect relationships
  startContext(parentId: HistoryId): void
  endContext(): void

  // Configuration - Runtime configuration changes
  updateOptions(options: Partial<HistoryTrackingOptions>): void
  getOptions(): HistoryTrackingOptions

  // Statistics - Performance and usage metrics
  getStats(): HistoryStatistics

  // Serialization - Save and load history data
  export(): SerializableHistoryEntry[]
  import(entries: SerializableHistoryEntry[]): void

  // Management - Cleanup and maintenance
  clear(): void
}
```

**Method Categories Explained:**

**Core Methods** handle the basic lifecycle of history entries:
- `addEntry()` is called automatically by the state machine when something happens. It returns a unique ID for the new entry.
- `getEntry()` lets you retrieve a specific entry by its ID, useful when following causality chains.
- `getAllEntries()` returns everything in chronological order, useful for building timelines.

**Query Methods** provide powerful filtering capabilities:
- `query()` is your main tool for finding specific events. You can filter by event type, time range, state names, or even use regex patterns to match event names.

**Causality Tracking** helps you understand cause-and-effect:
- `startContext()` tells the system "everything that happens next was caused by this event"
- `endContext()` ends that relationship, returning to normal tracking
- This creates parent-child relationships that help you trace how one action led to another.

**Configuration Methods** let you adjust behavior at runtime:
- `updateOptions()` lets you change settings like which events to track or memory limits without restarting
- `getOptions()` shows current configuration, useful for debugging configuration issues.

**Statistics Methods** provide insights into system behavior:
- `getStats()` returns metrics like total entries, memory usage, and event frequency distributions.

**Serialization Methods** enable data persistence:
- `export()` converts all history data to JSON-serializable format for saving to files or databases
- `import()` loads previously exported data, useful for debugging issues that happened in the past.

**Management Methods** handle maintenance:
- `clear()` removes all history data, useful for starting fresh or managing memory usage.

## Configuration Options

### HistoryTrackingOptions

```typescript
interface HistoryTrackingOptions {
  enabled: boolean;                           // Enable/disable tracking
  maxEntries: number;                        // Maximum entries (0 = unlimited)
  trackedEventTypes: HistoryEventType[];     // Which events to track
  includeInternalState: boolean;             // Include state machine data
  trackTiming: boolean;                      // Track execution timing
  trackCausality: boolean;                   // Track parent-child relationships
  defaultMetadata: Record<string, any>;      // Default metadata for all entries
}
```

### Default Configuration

```typescript
const DEFAULT_HISTORY_OPTIONS: HistoryTrackingOptions = {
  enabled: true,
  maxEntries: 1000,
  trackedEventTypes: Object.values(HistoryEventType),
  includeInternalState: true,
  trackTiming: true,
  trackCausality: true,
  defaultMetadata: {},
};
```

## Usage Examples

### Basic Setup

```typescript
import { StateChart } from './statechart';

// Enable history tracking with custom options
const historyOptions = {
  enabled: true,
  maxEntries: 500,
  includeInternalState: false,
  trackTiming: true,
};

const stateChart = StateChart.fromXMLWithOptions(xmlString, {
  history: historyOptions
});

// Access history
const history = stateChart.getHistory();
```

### Event Listening

```typescript
// Listen for history events
history.on('history', (payload) => {
  console.log('New history entry:', payload.entry);
  console.log('Total entries:', payload.totalEntries);
});

// Listen for memory management events
history.on('pruned', (data) => {
  console.log(`Pruned ${data.removedCount} old entries`);
});
```

### Querying History

```typescript
// Get all macrostep events
const macrosteps = history.query({
  eventTypes: [HistoryEventType.MACROSTEP_START, HistoryEventType.MACROSTEP_END]
});

// Get events in time range
const recentEvents = history.query({
  timeRange: {
    start: Date.now() - 60000, // Last minute
    end: Date.now()
  },
  limit: 100
});

// Get state-specific events
const stateEvents = history.query({
  stateFilter: 'playing.healthSystem',
  eventTypes: [HistoryEventType.STATE_ENTRY, HistoryEventType.STATE_EXIT]
});
```

### Statistics and Monitoring

```typescript
// Get execution statistics
const stats = history.getStats();
console.log('Total entries:', stats.totalEntries);
console.log('Memory usage:', stats.memoryUsage, 'bytes');
console.log('Events by type:', stats.entriesByType);
console.log('Execution timespan:', stats.newestEntry - stats.oldestEntry, 'ms');
```

### Export and Import

```typescript
import * as fs from 'fs';
import * as path from 'path';

// Export history for persistence
const exportedHistory = history.export();
const historyFilePath = path.join(process.cwd(), 'state-chart-history.json');
fs.writeFileSync(historyFilePath, JSON.stringify(exportedHistory, null, 2));
console.log(`History exported to ${historyFilePath}`);

// Import history from file
try {
  const savedHistoryData = fs.readFileSync(historyFilePath, 'utf8');
  const savedHistory = JSON.parse(savedHistoryData);
  history.import(savedHistory);
  console.log(`History imported from ${historyFilePath}`);
} catch (error) {
  console.warn('No existing history file found or failed to parse:', error.message);
}

// Async version for better performance with large files
async function exportHistoryAsync(filePath: string) {
  const exportedHistory = history.export();
  await fs.promises.writeFile(filePath, JSON.stringify(exportedHistory, null, 2));
  console.log(`History exported to ${filePath}`);
}

async function importHistoryAsync(filePath: string) {
  try {
    const savedHistoryData = await fs.promises.readFile(filePath, 'utf8');
    const savedHistory = JSON.parse(savedHistoryData);
    history.import(savedHistory);
    console.log(`History imported from ${filePath}`);
  } catch (error) {
    console.warn('No existing history file found or failed to parse:', error.message);
  }
}
```

## Integration with StateChart

The history system is automatically integrated into StateChart execution:

### Automatic Tracking

- **Macrostep Execution**: Start/end events with timing
- **Microstep Execution**: Individual transition processing
- **State Entry/Exit**: With timing and state information
- **Event Processing**: Internal and external event handling
- **Error Handling**: Automatic error capture and tracking

### Causality Relationships

The system automatically tracks parent-child relationships:

```
Macrostep Start
├── Event Processed
├── Microstep Start
│   ├── State Exit
│   ├── State Entry
│   └── Microstep End
└── Macrostep End
```

## Performance Considerations

### Memory Management

- **Automatic Pruning**: Old entries are automatically removed when `maxEntries` is exceeded
- **Configurable Retention**: Set `maxEntries: 0` for unlimited retention
- **Memory Monitoring**: Use `getStats().memoryUsage` to monitor memory usage

### Performance Impact

- **Minimal Overhead**: History tracking adds minimal performance overhead
- **Selective Tracking**: Configure `trackedEventTypes` to track only needed events
- **Optional State Inclusion**: Set `includeInternalState: false` to reduce memory usage

### Production Recommendations

```typescript
// Production configuration
const productionHistoryOptions = {
  enabled: true,
  maxEntries: 100,                    // Smaller buffer
  includeInternalState: false,        // Reduce memory usage
  trackedEventTypes: [                // Track only essential events
    HistoryEventType.STATE_ENTRY,
    HistoryEventType.STATE_EXIT,
    HistoryEventType.ERROR
  ]
};
```

## Debugging and Visualization

### Common Debugging Patterns

```typescript
// Find all errors
const errors = history.query({
  eventTypes: [HistoryEventType.ERROR]
});

// Trace execution path
const executionPath = history.getAllEntries()
  .filter(e => e.type === HistoryEventType.STATE_ENTRY)
  .map(e => e.metadata.enteredState);

// Find slow transitions
const slowTransitions = history.getAllEntries()
  .filter(e => e.duration && e.duration > 100); // > 100ms
```

### Visualization Integration

The history system is designed to integrate with visualization tools:

- **Real-time Updates**: Listen to 'history' events for live visualization
- **State Configuration**: Each entry includes current active states
- **Timing Information**: Duration data for performance visualization
- **Causality Tree**: Parent-child relationships for execution flow visualization

## Error Handling

The history system gracefully handles errors:

- **Non-blocking**: History errors don't affect state machine execution
- **Error Capture**: Automatically captures and stores execution errors
- **Graceful Degradation**: Continues operation even if individual tracking fails

## API Reference

For complete API documentation, see the TypeScript interfaces and JSDoc comments in:

- `src/models/history.ts` - Core types and utilities
- `src/models/state-execution-history.ts` - Main implementation
- `src/statechart.ts` - Integration with StateChart
